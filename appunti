Appunti di fondamenti di internet e reti - prof.Antonio Capone
/*********/
25 febbraio 2019

Lezione introduttiva
antonio.capone@polimi.it	0223993449
subject #FIR
Ricevimento in Bovisa il mercoledì 8.30 - 10:00
VIA room wi-fi
room name: 172.26.13.31
Code 2238
Materiale all'indirizzo home.deib.polimi.it/capone/ e http://www.antlab.polimi.it/teaching-capone/fondamenti-di-internet-e-reti
Laboratorio con Ing.Moro

Libro di riferimento: J.F. Kurose, K.W. Ross
Reti di calcolatori e internet 
edizione Pearson

Altro materiale:
	- slide
	- appunti
	- materiale a supporto del laboratorio
	- video lezioni su yt
	- letture suggerite
	- strumenti per lezioni e laboratorio

Laboratorio è parte integrante del corso dove si spiegano cose diverse dalla lezione
Meglio studiare prima di fare laboratorio
Se prof. va veloce fare domande

Organzizzazione corso:
	58h di lezione circa
	24h esercitazione circa
	18h laboratorio fisse

Esercitazioni poste alla fine di ciascun argomento
Laboratorio si svolge qui, in aula B8.1.1 (ci sarà una volta in cui saremo in B8.0.3 che non è dotata di presa eth)
BYOD

Prove in itinere:
	1) 17 Aprile
	2) fine corso, prob. 2 luglio
	durante la seconda prova anche appello completo

Esame solo scritto
	3 esercizi simili a quelli visti a lezione/eserc
	1 esercizio di laboratorio
	domande risposta aperta/chiusa
	5/6 pt x es, 8/9pt x domande, 6pt laboratorio, totale 32punti
Punti extra per chi frequenta: alla fine di ogni capitolo (sono 5) ci sono dei test online fatti su kahoot.it in classe usando PC, smartphone o tablet
	3pt per frazione di risposte esatta su totale complessivo 3x(0.boh)
	1 punto premio per chi vince la gara di ogni capitolo
	Non è possibile rispondere da remoto

No orale se non per casi critici

Scopo: 
Introduzione alle interfacce di rete
Controllare interazione tra app e rete, configurare rete, prevedere il comportamento della rete e prestazioni, monitorare il sistema e risolvere i problemi, pronti ai cambiamenti tecnologici

Le applicazioni sono sempre più distribuite 

Oggi sviluppare un'applicazione comporta
	1) scrivere le componenti server
	2) inserirle in VM
	3) istanziarle su un servizio cloud
	4) Scrivere le componenti cloud per più piattaforme
	5) Inserirle negli store
	6) Aspettare che gli utenti scarichino le app
	7) COntrollare la relazione con la rete

Applicazioni di reti
Tendenza SDN, Software Defined Network, ovvero controllare la rete con applicazioni di rete, costituisce una grande fetta di mercato di lavoro

Comeptenze miste per ingegneria dell'informazione 

Primo corso che dà un assaggio di indirizzo comunicazione, divisi al terzo anno
Al secondo anno ci sono scelte parzialmente vincolanti

3 scelte 
	logica e algebra - insegnamento taba OPPURE elettromagnetismo e campi
	e altre, le slide sono sul web @ https://www.dropbox.com/s/74xcv629ddkfg1k/1 - Introduzione e architetture v2019.pdf 
	informazione e stima è insegnato da ingegneri, probabilità e statistica da matematici
	per info logica e algebra per info

logica e algebra + taba + algoritmi e principi per info (X INFORMATICA)
se indeciso anche informazione e stima, gruppo taba onde el. e mezzi trasmissivi, API

x com indecisi
	informazioni e stima
	el. e campi
	logica e algebra e onde el. e mezzi
	segnali per le comunicazioni

Breve storia di internet
ARPA Network (ARPANet) nel 1969 (4 nodi)
Padri: Kleinrock, Lawrence Roberts
1972: nasce NCP, primo porgramma di posta elettronica, 15 nodi di arpanet
1970: ALOHAnet rete radio a pacchetti per univ. Hawaii
Cerf and Kahn definiscono i principi dell'internetworking
1976: nasce Ethernet nei laboratori Xerox @10Mbps
1979: ARPANet 200 nodi

Anni '80: nasce SMTP, FTP, DNS. TCP/IP sostituisce NCP
Nuove reti nazionali: Csnet, BITnet, ...
Per il web bisogna aspettare gli anni 90 (Tim Berners Lee), Mosaic->Netscape
Anni 2000: problema di sicurezza (Diffie-Hellman-Merkle) velocità in Gbps
2010 - oggi: esplosione mobile internet, arrivano smartphone
CAIDA's IPv4 Map Feb 2017

99% del traffico internazionale di internet è sui cavi sottomarini
cybermap @ kaspersky

Programma del corso (prima parte):
1) Introduzione e architetture
2) Sistemi di comunicazione
3) Modelli funzionali
4) Livello fisico 

Approccio TOP-DOWN (della pila ISO/OSI)

Martedì 12 Marzo pomeriggio in Leonardo siamo invitati ad un seminario per vedere un esperimento di fotografia, digitalizzazione e invio nell'edificio 20.

seconda parte
5) protocolli applicazivi
6) trasporto (UDP/TCP)
7) livello di rete (networking)
8) inoltro in internet (inoltro, instradamento)
9) rete locale e livello di linea (Layer 2)

In laboratorio usiamo wireshark, ping, traceroute, dig, F12 di chrome, protocolli applicativi
Python escripting per analisi di rete
Programmazione socket in Python
Packet tracer
attività sperimentali su wireless

//note4selfl8r https://www.jetbrains.com/pycharm/download/#section=linux

è possibile frequentare il CORSO CCNA e fare il test CCNA. Il test costa poco (<100 €) ma la preparazione un po'di più
Ci sono 4 moduli
CCNA1, ..., CNNA4

Giochiamo con un analogia per capire il networking
Nome Cognome Indirizzo

parliamo di rotte (route), router,
prova con kahoot

NICKNAME: CODICE PERSONA + PRIME 6 LETTERE DEL COGNOME

velocità di propagazione = velocità luce 299 792 458 m/s
/**********/
Mercoledì 27 febbraio 2019
/**********/
Argomenti: Concetti base, architettura e componenti, meccanismi base e nomenclatura
Cos'è internet?
	1) È un'infrastruttura fisica fatta di componenti
	2) Un'architettura di rete
	3) Un servizio di comunicazione (comprende protocolli di comunicazione)
Componenti fisiche: 
	HOST = terminali connessi alla rete
	LINK = collegamenti = canali di comunicazione (rame, fibra, satellitare)
	ROUTER = nodo di rete
	altri nodi di rete locali (switch, access point, modem,...)
	
	HOST
		sono in grado di inviare e ricevere info su internet
		sono diversi tra loro pc, stampanti, iot devices, server
		host virtuali VM che non facciamo in questo corso
	LINK
		possono essere di natura fisica diversa(rame, radio, fibra ottica, ...), diversa tecnologia di trasmissione dell'informazione, diverse velocità di trasmissione in bps
	ROUTER
		Sono nodi di rete che operano sui pacchetti
		opera a 3zo livello pil ISO/OSI (solo router), switch 2ndo livello, alcuni anche terzo
		anche access point
ISP ->internet service provider col quale ci si connette tramite tecnologie di accesso a internet
Accesso a internet: dialup
	via modem fino a 56kbps; accesso diretto al router dell'ISP mediante circuito telefonico; trasmissione del segnale in banda fonica
	Molto ristretto perché limitato alla banda telefonica 0 - 4 kHz
Accesso tramite ADSL ( asimmetric digital subscriber line)
	fino a 1Mbps upstream, 20 Mbps downstream)
	condivisione del doppino con la rete telefonica fino alla centrale
	accesso al router del provider mediante rete dati ad alta velocità
	Il segnale non passa dalla rete telefonica (limitata dalla banda), per cui si basa sulla qualità del doppino telefonico
Accesso tramite fibra ottica
	Sostituzione totale/parziale del doppino telefonico con fibra ottica
	FTTH - Fiber to the home
	FTTB
	FTTC
	FTTN
Accesso tramite rete cellulare
	GPRS/EDGE ~200kbps
	HSPA ~14,5(D)/5,7(U) Mbps
	LTE ~300(D)/85(U) Mbps
	rete d'accesso contente core network mobile operator

Reti di reti
	Consente di fare comunicare diverse reti interconnesse cucite insieme in qualche modo
	ISP
	Eterogeneità della reti con meccanismi di interconnessione(protocollo IP)

Tipi di reti in base all'estensione geografica
	LAN: local area network
	MAN: metropolitan area network (cabine cittadine)
	WAN: wide area network
	
Architettura di interconnessione
	CN = customer network (rete casalinga, utente finale)
	POP = point of presence (altro estremo rispetto al CN, più vicino a ISP, È il punto di giunzione)
	ISP = internet
	NAP = neutral access point o MIX, IEP (internet exchange point, ce ne sono 2/3 in italia, 1 a milano caldera, 1 a Napoli). Diversi nodi di più operatori in un luogo di terzi si connettono tra di loro. Scambio di traffico dati. Possono esistere collegamenti diretti peer-to-peer tra ISP. Gerarchie tra ISP.
	BSP = Backbone Service Provider. È il fornitore di servizi internet agli ISP per collegamenti internazionali / intercontinentali.

Servizio e protocolli di comunicazione
	Servizio di comunicazione può essere il servizio postale. Esistono regole di consegna se no niente servizio. Quello che c'è nella lettera non è affare della posta.
	Il servizio di comunicazione è il rapporto cliente(alto)-fornitore(basso)-destinazione(alto).
	Servizio SOCKET: meccanismo per accedere all'interfaccia di rete (trasporto LV4) dal SO.
	Si possono trasportare messaggi di vario tipo, dalle più complesse alle più semplici
	
	Protocollo di comunicazione: stessa lingua, ordine dei messaggi
	Esempio della posta elettronica SMTP sulle slide
	Modelli:
		-client-server: uno funge da client (richiede), l'altro da server(risponde) (es. SMTP, HTTP, ...)
		-peer-to-peer: i terminali collaborano senza distinzione di ruoli (fungono sia da server che da client) (gnutella, ...)
	
Come funziona internet? DOmanda occupa l'intero corso
Come può essere trasferita l'info?
	1) Commutazione di circuito
		Rete fatta di fili cuciti insieme per arrivare a destinazione che potevano essere manuali (centralinista). Pezzi di filo con ponti fatti a mano.
		La figura del centralinista è sostituita da mezzi automatici ma la commutazione di circuito era rimasta nella telefonia fissa
		Condivisione della rete.
		Ricerca di circuito, apertura del circuito e conversazione tramite impulsi elettrici. Una volta terminata la conversazione i brani di filo vengono rilasciati.
		Necessita di fili, conduttori separati. 
		Suddivisione della banda del collegamento in frequenza o in tempo
		Collegare insieme ingresso e uscita con modello di nodo (commutatore a circuito).
[ Numero di archi in un grafo completo = n*(n-1)/2 ]
	2) Commutazione di pacchetto
		informazione suddivisa in pezzi;
		collegamenti non suddivisi;
		ciascun pezzo (pacchetto) ha una intestazione (header) che indica l'indirizzo di destinazione e altre informazioni per la comunicazione che è diverso dal contenuto.
		Non esiste un canale dedicato, il pacchetto fa dei salti tra router
		I router possiedono una tabella di instradamento che assegnano un gruppo di indirizzi di destinazione al nodo verso cui inoltrare le informazioni
		I router hanno computazione parallela e non sequenziale per gestire meglio la gestione della lista. 
		
		Il flusso di dati è suddiviso in pacchetti che occupano completamente il canale, poi da ricucire insieme
		
		Modello di nodo (packet switch/ router)
			l'arrivo dei pacchetti è asincrono; la capacità dei collegamenti è arbitraria; possono esserci conflitti temporali per la trasmissione;
			serve memorizzare contemporaneamente (coda): in ingresso per analizzare indirizzo destinazione; in uscita per gestire confitti

		Contesa per le risorse: 2 modi per gestire le cose
			store and forward: il commutatore deve ricevere l'intero pacchetto prima di inviarlo sul collegamento in uscita: non si elabora se non è completamente ricevuto
			cut-through: altra modalità di gestire le code (per questo corso dimentichiamocelo) che inizia ad inviare prima di avere ricevuto i dati ma solo l'header
	Confronto tra pacchetto e circuito
		Collegamento da 1 Mbps, n utenti. Utente genera 100 kbps quando è attivo; è attivo per il 10% del tempo.
		-> commutazione a circuito con 10 utenti: 10 utenti (1 Mbps / 100 kbps = 10)
		-> c. a pacchetto: con 35 utenti, la probabilità di avene >10 attivi è 0,004%.
		
	La storia di internet nasce con la scelta della comutazione a pacchetto.
	
	Esistono 2 tipi di comm. di pacch. 
		- datagram (IP)
			la scelta della porta è fatta basandosi sulla porta di destinazione

		- circuito virtuale (tecnologie usate dagli ISP per gestire in modo + efficiente i collegamenti internet)
			assegnazione di un label univoco (CVI) ad ogni pacchetto
			tabelle più corte perché basate su CVI ma più dispendioso per scrivere le label


1c - Ritardi e throughput: tempi di trasmissione, propagazione, altri ritardi, throughput
Velocità di trasmissione
	È la velocità (rate) R con cui l'info digitale viene trasmessa su una linea = num. bit nell'unita di tempo
	È misurata in bit/s (bps) (bit per second)
	1 B = 8 b;
	1 kbps (kb/s) = 10^3 bps; 1 kB = 10^3 B;
	1 Mbps
	1 Gbps
	durata di trasmissione di un bit è inverso della frequenza

	Il tempo T per trasmettere L bits dipende dalla velocità di trasmissione R
	L [b] , T [s], R [bps]
	T = L / R
	[s]^1 = [b]^1 / ([b]^1 * [s]^-1) = [s]^1 = [b]^1 * [b]^-1 * s[1] = [s] = [s]

	Il max della velocità nell'universo è la velocità della luce
	Il ritardo di propagazione
	Il tempo tau affinché un impulso trasmesso dal trasemttitore TX raggiunga il ricevitore RX dipende dalla distanza D in m e dalla velocità di propagazione v in m/s, prossima alla vel. della luce (= c = 3*10^8 m/s
	tau = D / v
	tau [s] = D [m] / v [m/s]
	Noi assumiamo che la velocità di trasmissione sia 2/3 della velocità della luce (200.000 km/s)
	Tempo di attraversameto del canale = T + tau
	
	T = t2-t0 = t3-t1 = L/R (si riferisce a esempio slides)
	tau = t1-t0 = D/v
	
	Esempio di store and forward supponendo che l'elaborazione nel router di mezzo sia immediata
	Tempo totale = TAB + tauAB + TBC + tauAB
	Si suppone solo che sia store and forward

Architettura di un nodo (software-switch vs hardware-switch)
	Tante NIC collegate al bus I/O. C'è system bus tra memory e CPU.
/*********/
Giovedì 28 febbraio 2019
/********/
Nella lezione precedente ritardo di un nodo
2 modelli: modello classico di un nodo simile ad un PC con CPU, mem e più NIC; nodo con architettura hardware dedicata.
Tempo attesa pacchetti in ingresso (quasi nulla per nodi con hw switch)
Capacità di processamento è limitata dal tratto in uscita del nodo. Spesso la capacità è misurata in bit/s (in realtà pacch/s moltiplicate per la lungh. media del pacchetto)
2 ragioni del ritardo tau: linea occupata o lookup della tabella. Spesso il lookup della tabella è 0, per cui noi assumiamo che sia 0, l'accodazione dei pacchetti dipende.

(slide 115) un nodo della rete continua a trasmettere a velocità più alta possibile (livello 3, a livello di trasporto le cose cambiano)
	ci sono 2 pacchetti: a e b trasmessi da A a B. Ma T2A è aumentata perché la velocità del collegamento 2 è inferiore a quella del link 1.
	Il pacchetto verde (b) non può quindi essere trasmesso subito, ma deve aspettare che il pacchetto viola arrivi.
	Quando il pacchetto viola è stato trasmesso parte la seconda trasmissione.
*	T1B non è preso in considerazione perché la trasmissione avviene in parallelo, si conta il più lungo.
(slide 116)
*	In questo caso i due pacchetti vanno in due parti diverse e vanno mandati nello stesso momento

Multiplazione statistica
	Il ritardo di accodamento dipenda della velocità del link e dal ritardo in uscita 
	La coda non serve per compensare alla velocità in uscita dal link
	Pacchetti droppati

	Ritardo di accodamento 
	L -> lunghezza dei pack
	lambda -> frequenza dei pack
(slide 120)
	Quindi se l'intensità di traffico ~0 allora ritardo in coda è piccolo, se ->1 (tende a) il ritardo tende all'infinito
(s. 121) formula del ritardo di accodamento medio
Se il ritmo di avvio si avvicina al ritmo di uscita allora ritardi e packet drop.

Perdite di pacchetti
	le code hanno dimensioni limitate. In congestione (ritmo di arrivo troppo elevato), i pacchetti vengono scartati
	i pacchetti persi possono essere ri-trasmessi oppure no a seconda del protocollo di trasporto che gestisce l'evento di perdita.
	
1d - modelli di servizio e livelli dei protocolli
(servizio di comunicazione, protocolli, primitive di servizio, architetture a livelli, funzioni di rete)
Esempio dei due interlocutori come due entità (A e B) che vogliono comunicare.
In orizzontale avviente il colloquio, in verticale il servizio.
Primitive di servizio: chiamate di servizio.
	\-> regole di accesso, descrivere il s., richiederlo, ricevere informazioni.
	\-> caratterizzate da parametri quali: info da trasferire, info destinatario, caratteristiche del servizio
	
Le primitive possono essere considerate dei punti di passaggio (service access point).
___nodo a__                    ____nodo b_____
|ente A   |                    |     ente B   |
|         |                    |              |
|   A2    |<--colloquio------->|      B2      |
|         |                    |              |
|         |                    |              |
|   A1    |<------colloquio--->|      B1      |
|         |                    |______________|
|_________|                          ^
       |_____________________________| 
              Canale bidirezionale

(slide 130)
2 modalità di servizio di comunicazione:
	Modalità senza connessione (UDP, ndr)
		- una sola fase di invio
	Modalità a connessione (TCP, ndr)
		- instaurazione della connessione
		- trasferimento della informazione
		- rilascio della connessione

Le reti sono organizzate a livelli: i colloqui devono essere mediati dai livelli inferiori
Le reti sono divise in pezzi orizzontali per semplificare le cose una alla volta
I livelli servono ad arricchire il servizio di comunicazione

Protocolli di comunicazione 
	la logica con cui creo, trasmetto e ricevo i messaggi è un protocollo. (es. grammatica per il colloquio)
	Insieme di regole per colloquiare tra lo stesso livello
	Non c'è un solo modo. problema delle scelte da prendere.

PDU = Packet Data Unit = unità di trasferimento dati. È formato da:
	header 	-> informazione di servizio necessaria al coordinamento tra le entità
	dati 	-> informazione vera e propria ricevuta dai livelli superiori

Architettura a livelli (s. 134)
	Overhead = info. aggiunta (header)

PILA ISO/OSI (questa non l'ha considerata per ora)
____________________
|Application   Lv 7|  MESSAGES - MESSAGGI
|__________________|
|Presentation  Lv 6| 
|__________________|
|Session       Lv 5|
|__________________|
|Transport     Lv 4|  SEGMENTS - SEGMENTI
|__________________|
|Network       Lv 3|  PACKETS - PACCHETTI
|__________________|
|Data link     Lv 2|  FRAMES - TRAME
|__________________|
|Physical      Lv 1|  BIT
|__________________|

Ciascun livello ha il suo compito
È più facile gestire aggiornamenti e cambiamenti se limitati a solo un livello

PILA TCP/IP

____________________
|Application   Lv 5|  MESSAGES - MESSAGGI
|__________________|
|Transport     Lv 4|  SEGMENTS - SEGMENTI
|__________________|
|Network       Lv 3|  PACKETS - PACCHETTI
|__________________|
|Data link     Lv 2|  FRAMES - TRAME
|__________________|
|Physical      Lv 1|  BIT
|__________________|

Wireshark: analisi pacchetti di rete
	\-> è uno sniffer di rete. È un modulo interamente passivo che non può inviare pacchetti autonomamente.
	formato file .pkcap
	
	Il packet analyzer consente di analizzare i contenuti e lo header dei pacchetti
	wireshark è solo una interfaccia grafica, il motore è libpcap / WinPCap.

	00:00:0c -> cisco

Funzione Multiplazione (per l'andata, demultiplazione in ricezione)
	mettere insieme e separare flussi informativi
	più livelli superiori possono condividere lo stesso servizio di comunicazione, per cui devo potere distinguere le informazioni con una "etichetta"
	Il numero di porta di TCP (lv.4) serve a questo scopo
	Una macchina può avere più applicazioni, che sono distine in base ad un numero di porta.
	La funzione di multiplazione può essere implementata a qualunque livello.
(slide 142)	
Funzione di controllo d'errore
	Garantire affidabilità nella trasmissione (CRC)
	Trasmetto un pacchetto e alla fine aggiungo il trailer (coda) composta dal codice di controllo
	Acknowldedgment e timeout
	
Funzione di instradamento (routing)
	\->trovare la strada verso un'altra rete
	Esiste una entità e più uscite. Da dove arriva il pacchetto? Dai livelli superiori (es. lv n)
	L'indirizzo va messo prima che venga inviato all'entità instradante.
	L'indirizzo del livello n  viene scritto e si decide dove inviarlo a seconda della tabella di instradamento.
	
	Il pacchetto può arrivare da una porta di ingresso.
	L'entità instradante fa il forwarding (consulta la tabella e viene inoltrato verso l'interfaccia corrispondente in tabella).
	
	esempio slide 145
	nei nodi di rete i livelli considerati dagli apparati router si fermano al livello 3. Gli switch idem ma con il livello 2.
	Proxy: funzione di rete a livello applicativo.
	Chi scrive le tabelle di instradamento?
		\-> "Human defined Networking": rotte statiche scritte a mano.
		\-> MAC learning fatto dalle macchine di rete
		\-> "Software defined networking" SDN
/*********/
Mercoledì 6 marzo 2019 (sì, ho perso una lezione)
/*********/
reminder demo/seminario livello fisico martedì 2019-03-12 h.16:00 EL.0 (Leonardo) max.2 ore
1b. livello fisico
aspettiamoci il primo kahoot
Segnali e frequenze
Siccome non abbiamo visto le trasformate in analisi 2, abbiamo meno strumenti per comprendere questa cosa
I segnali: sorgenti di informazioni che possono essere
	digitali, numerici

	segnali fisici: sorgenti continue
	(es. radio FM vs DAB: digital audio broadcasting)
	a noi interessano i segnali digitali. Conversione da analogico a digitale attraverso campionamento e quantizzazione. In output avremo dei bit
	
	segnali nel dominio del tempo? Meglio di no, è più comodo vedere i segnali nel dominio delle frequenze.
	Con la trasfomata di Fourier.
	Tempo misurato in secondi, frequenza in Hz (secondo alla meno 1) [T]^-1
	I segnali sono scomposti in molte sinusoidi, che sono le frequenze che lo compongono.
	Lo spazio in cui la f ha valori =/= 0 si chiama banda del segnale
	L'analisi di Fourier è comoda per segnali periodici, come le sinusoidi. 
	Insieme continuo vs discreto.
	L'onda quadra è formata da una serie di Fourier di sinusoidi (se è periodico, se è discreto la trasformata).
	s(t) nel dominio del tempo e S(t) (che è lo spettro del segnale) è nel dom della frequenza.
	Se continuo a sommare sinusoidi con tutte le sue armoniche ottengo un onda quadra nel dom. del tempo.
	La banda di un onda quadra è infinita ( perché la pendenza è verticale), ma noi prendiamo una banda limitata.
	Più le transizioni sono nette, maggiore sarà la banda
	media nulla = non c'è la componente continua (f=0), altrimenti c'è ed è costante
	la media non è nulla perché il grafico era spostato verso l'alto e non era alternato
	Esempio onda a dente di sega.
	I segnali non periodici non hanno uno spettro discreto ma continuo
	SYNC ha banda infinita e spettro è sin(x)/x . Bisogna tagliare le frequenze esterne del sync per poterlo spedire. Cambierà un pochino la forma del segnale
	Banda stretta (segnale che varia lentamente) e banda larga: varia velocemente nel tempo.
	Più la banda è larga più energia in TX ci vuole.
	

	Segnale telefonico ha banda (300 - 4000 Hz) Fc:	8KHz	lv.	256	8 bit			 Flusso binario	64  kb/s
			voce 				(300 - 8000 Hz)		16KHz			16 bit							256 kb/s	
			musica 				(100 - 8000 Hz)		40KHz			16 bit							704 kb/s
			TV(PAL) (analogica) (0 - 5 MHz)			10MHz			24 bit (colori)					240 Mb/s
			cinema 				(0-500 MHz)			1GHz			24 bit (colori)					24  Gb/s
	
Conversione analogico-digitale
	Rappresentazione umana: modo analogico
	Elaboratori numerici: discreto
	
	Diversi passaggi
	1) CAMPIONAMENTO
		Definisco un periodo (frequenza) di campionamento
		
		Teorema di Nyquist(-Shannon questo lo dico io)
			fc >= 2B = fN (frequenza di Nyquist)
			(la frequenza di cmapionamento deve essere 2 volta la banda per poter essere ricostruita)
		
		Se non rispettiamo il teorema di Nyquist, il segnale ricostruito è sbagliato, alterato. Evitare questo
		Se la banda è larga bisogna aumentare la frequenza di campionamento, altrimenti no
		
		Con un filtro rimuovo le frequenze non deisderate (somiglia ad un mezzo trasmissivo)
		Sempre con un filtro passa basso (da 0 a 2B)riottengo il segnale originale 
	
	2) QUANTIZZAZIONE
		È l'operazione che trasforma un segnale da continuo a discreto.
		Quindi sull'asse delle ordinate non ci saranno più tutti i numeri ma solo un certo numero di "gradini"
		Nella trasformazione si commette un errore di approssimazione (quantizzazione)
		Più livelli ci sono meno errori di quantizzazione. Ogni livello è rappresentato da una sequenza di bit
		Ricondurre poi ciascun campione ad un livello

		l = 2^b
		l = num.livelli di quantizzazione
		b = num.bit per livello

Modulazione e trasmissione
	La trasmissione di un segnale digitale (numerico) richiede di creare un opportuno segnale adatto per essere trasportato sul mezzo fisico.
	La sequenza digitale viene usata per modificare (modulare) un qualche parametro del segnale (modulato) inviato nel mezzo trasmissivo.
	Modulazione in banda base (spettro contiguo rispetto all'origine)
	Banda traslata (non vicine allo 0)
	Modulazione in banda base basata sugli impulsi.
	PAM - Pulse Amplitude Modulation
		\-> il bit corrisponde ad un impulso di ampiezza positiva (1) o negativa (0)
	
	Modulazione in banda traslata:
		si crea un onda EM (sinusoide) detta PORTANTE (carrier) ad una determinata frequenza (fp) per traslare lo spettro del segnale intorno alla frequenza della portante
		
	R = 2B
	In caso di modulazioni in banda traslata efficienza spettrale = 1 bit per Hz
	Onde elettromagnetiche

	Modulazione in banda traslata
	\->	ASK Amplitude Shift keying	: modulazione in ampiezza della carrier
		FSK Frquency				: modulazione in frequenza carrier
		PSK Phase					: moudulazione in fase carrier
		QAM	(quadratura)			: cambiamento misto di ampiezza e fase
	
	Modulazione multilivello
		impulsi su più livelli (es. 8-PSK, 16QAM) (sul cellulare fino a 256 livelli)
	
	Aumenta l'efficienza spettrale. SImboli al secondo = baud (vecchio nome)
	Esiste un valore massimo di robeh calcolata da Shannon
	
	Mezzo trasmissivo: riceve il segnale in ingresso e lo trasporta, ma viene alterato (es. ritardo, minor potenza).
	Attenuazione	della potenza in funzione dela distanza percorsa e della frequenza del segnale;
	Dispersione		ritardo differente per ogni componente in frequenza
	Banda passante del canale (mezzo trasmissivo) è la regione in cui si ha la migliore risposta in termini di attenuazione e dispersione.
	
	Mezzi trasmissivi guidati(wired) o non guidati (wireless)

	Attenuazione = Pout/Pin in dB. A(dB) = 10logb10(Pout/Pin)
	A = kd^-x	x=2,3,4,5
	
	Errori in ricezione.
	Cause:	- rumore termico (mezzi trasmissivi, apparati di tx e rx)
			- interferenza
			- other
	Il rimore è un processo casuale 

	Codici correttori
		Si può abbassare la probabilità di erore in un blocco con codicei correttori d'errore (Forward Error Correction FEC) = bit di ridondanza/parità
	Ritrasmissione: se ci sono errori, ritrasmetto il pacchetto errato (ARQ - Authomatic Repeat reQuest)
	
	Capacità di canale dimostrata da Claude Shannon nel 1940.
		C = B*logb2(1+S/N)

		C 0 capacità del canale [bps
		B = banda del canale [Hz]
		S = potenza del segnale [W]
		N = potenza del rumore [W]
/**********/
Giovedì 7 marzo 2019
	
Speigone sulla lezione di ieri (modulazione e trasmissione).
Banda base (origine) e banda passante (lontana).
Modulazione in banda traslata è un casino
Efficienza spettrale media

A  sin(2*pi*f *t+fi )
 k           p     k

Ak = ampiezza; fp = frequenza; fik = fase
Modulazione multilivello

s(t)  _______   r(t)                   r(t) = b * s(t+tau)  	b è la costante di attenuazione
----->| H(f) |------->              
S(f)  |______|  R(f) = s(t) * H(f)     R(f) = g * S(f)

Attenuazione è rapporto tra potenze
Codici correttori
	Bit di parità: sono due bit messi in fondo alla stringa che fanno in modo che i bit in posizione dispari e pari rispettivamente siano entrambi pari
	Es.  __________________
        | 00111111100010|11|
Cont.   |_______________|__|
Dispari   0 1 2 3 4 4 5  6
Pari       0 1 2 3 3 3 3  4

IL LIVELLO APPLICATIVO

Processi e socket, peer-to-peer, web, mail, DNS

Studiamo i seguenti protocolli applicativi
HTTP, SMTP, BitTorrent, Video streaming

Creare un'applicazione di rete è scrivere un software che possa essere eseguito su diversi terminali e possa comunicare tramite la rete
Obiettivo del laboratorio con applicazioni di rete è fare una cosa semplice che funzioni in rete

I nodi della rete non hanno software applicativo, le applicazioni sono installate solo sui terminali
Comunicazione tra processi. Attori: host, processo e IPC (comunicazione tra processi).
/**********/
Lunedì 11 marzo 2019

Cosa contiene pagina HTTP?
Locator: URL
La pagina è fatta di oggetti (file HTML, applet java, video,...)
URL composto da protocollo applicativo, indirizzo del server, porta e pagina richiesta

HTTP è client-server con protocollo stateless (nessuna memoria sulle richieste è mantenuta sul server con il protocollo HTTP).
La comunicazione è fatta con richieste e risposte (protocollo asimmetrico)
HTTP si poggia su TCP e utilizza la porta server n.80 di default.

2 modalità: non persistente e persistente
	non p.: c'è una connessione per ogni oggetto, chiusa ogni volta che il trasferimento è terminato. (parallelo)
	pers. : la connessione viene lasciata aperta e invia in serie le richieste una dietro l'altra

Tempo impiegato per trasferimento in andata e ritorno: RTT, piccolo pacchetto
Tempo totale è una sommatoria di RTT + tempo di trasferimento del file
Le richieste HTTP
	sono codificati in ASCII (utile perché leggibile, ma più dispendiosa in termini di bit occupati dal messaggio).
	Nello header c'è il tipo di messaggio, host, user-agent, linguaggi accettati e se è persistente oppure no.
	HTTP 1.1 è keep-alive (persistente) di default, la versione 1 era non persistente di default
I metdodi HTTP:
	GET		chiede pagina
	HEAD 	chiede informazioni sul documento
	POST	fornire input al server utilizzabile da un oggetto
	PUT		memorizzare un documento nel server
	DELETE	elimina documento
Esempi di header:
	cache-control:		info sulla cache
	accept:				formati accettati
	accept-language:	linguaggi accettati
Le risposte HTTP
	contiene lo status code, identificati da un codice di 3 caratteri.
	1xx	info
	2xx success
	3xx redirect
	4xx client error
	5xx server error
messaggi accompagnati da scritta in inglese
Esempio pratico col telnet

Contitional GET
	Serve per non scaricare gli oggetti se non sono stati modificati dalla data dell'ultimo trasferimento
	L'header da inserire è if-modified-since: <date>
	Se l'oggetto non è modificato, viene resttuito il messaggio 304. Il browser visualizzerà la copia locale anziché quella sul server

youtu.be/astJTu59BfY 	richiedere pagine con http1.1
youtu.be/YfIILUI5S0E 	inviare get condizionato

strumenti per l'analisi del traffico HTTP all'interno del browser web
	Chrome dev tools
trasferimento files con curl curl -o /dev/null -s -w "%{time_total}\n" www.antlab.polimi.it
trasferimento file con telnet

Esempio telnet:

lorenzo@lorenzo-VirtualBox:~$ telnet antlab.elet.polimi.it 80
Trying 131.175.187.69...
Connected to antlab.elet.polimi.it.
Escape character is '^]'.
GET /images/antlab_small.jpg HTTP/1.0

HTTP/1.1 302 Found
Date: Mon, 11 Mar 2019 12:14:34 GMT
Server: Apache
Location: https:///images/antlab_small.jpg
Content-Length: 216
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href="https:///images/antlab_small.jpg">here</a>.</p>
</body></html>
Connection closed by foreign host.

fine esempio. 

Mantenere lo stato in HTTP: i cookies
	Strumento utilizzato dal server per memorizzare qualcosa sul client
Memoria condivisa: il PROXY
	Le richieste inviate a qualunque server sono deviate verso una macchina chiamata PROXY, che risponderà a tutte le richieste che farò.
	Il proxy chiederà al destinatario originario la risorsa e la inoltra al client.
	È un intermediario. In aggiunta a ciò se l'oggetto è disponibile nella cache del proxy server esso risponde con l'oggetto.
	I proxy sono APPLICATION GATEWAY

Curiosità: differenze tra HTTP versione 2 e versione 1.1.
	v2 è in binario e non in ascii, multiplazione, compressione header, servizio di server push (scarica anche elementi collegati).
	DEMO: https://http2.akamai.com/demo
	indexing e codifica differenziale

Sicurezza in HTTP con il protocollo sicuro HTTPS
	confidenzialità: solo chi può ricevere riceve
	integrità: nessuno modifica i dati
	autenticazione: chi invia è veramente chi dice di essere

	Connessioni SSL/TLS: 1) handshake con autenticazione da ambo i lati. Poi vengono scambiate le chiavi di cifratura. 2)Trasferimento dati. 3) Chiusura connessione
	Crittografia simmetrica ed asimmetrica (root certificate = certificati truffaldini)

/**********/
Giovedì 13 marzo 2019

Il servizio di posta elettronica
SMTP RFC 5321
POP3 RFC 1939
IMAP RFC 3501

Il servizio consiste in un client aka user-agent, di un mail server, di un protocollo di invio (SMTP) e dei protocolli di accesso per scaricare la posta (POP3, IMAP)
Ciascun server gestisce un dominio e gli utenti validi devono avere una casella che corrisponde ad un indirizzo valido (il dominio è quello dopo @)
Il server di posta in uscita funge da proxy (riceve e poi invia, inoltra, fa da intermediario). 
Questo è come funzionava, oggi c'è un livello di sicurezza in più col server in uscita che chiede l'autenticazione dell'utente.

SMTP
	Protocollo client-server che usa TCP con porta nota lato server 25.
	Mette il messaggio in coda, apre connessione con il mail server del destinatario, trasferisce il messaggio e chiude la connessione TCP.
	Comandi e risposte testuali in ASCII, come pure i messaggi.
	
	Esempio di trasferimento.
	Colloquio tra client e server SMTP.
	Messaggio composto da Header (to, from, cc, subject) e dal body.
	I messaggi finiscono tutti con una punto soltanto su una linea

	Multipurpose Internet Mail Extensions MIME (RFC 2045-2046)
	Estende il formato dei messaggi email per trasferire dei contenuti diversi dal testo ASCII. (es. immagini, video, HTML)
	Bisogna aggingere degli header
	MIME-Version: 1.0
	Content-Transfer-Encoding: base64
	Content-type: image/jpeg
	
	Potrebbero anche esserci più parti in un testo (allegati).
	Esempio di invio email
Protocolli di accesso al mailbox attraverso 2 protocolli: IMAP o POP3. Può anche essere fatta attraverso HTTP per la webmail
POP3. Più semplice e con meno funzionalità
	- Connessione al server (TCP port #110)
	Questi sono i comandi utilizzabili
	- user: user lorenzo
	- password: password prova123ssassa
	Risposte del server: +OK oppure -ERR
	Fase di transazione in cui il client fa
		list
		retr	
		dele
		quit
IMAP: vantaggio delle directory
	
VIDEO: youtu.be/v4Zpywa8ag0
Scopo: inviare una email da un mittente falso al proprio indirizzo di posta elettronica

Conversione tra nomi simbolici e indirizzi:
DNS - Domain Name System
Converte da nome a numero (è un servizio di pagine gialle distribuito)

È composto da database distribuito costituito da molti name servers con organizzazione gerarchica. Il servizio è basato su UDP.
Servizi aggiuntivi: host aliasing (sinonimi), mail server aliasing, load distribution

I server sono organizzati con la stessa gerarchia dei domini
	.com		.it			.org		TLD (Top level Domain)
bing		polimi		wikipedia		nome a dominio
										

La parte di organizzazione semplice, organizzazione un po' più complessa.
13 root name servers (NS).
Local name server è quello che fa da interfaccia tra utente e mondo dei server DNS.

Server authoritative è responsabile di quel particolare hostname
Se il server ce l'ha in cache e fornisce risposta senza contattare il server la risposta è non-authoritative
Ogni host ha un LNS (local name server) che fornisce alle applicazioni i nomi a dominio e li tiene in cache

Esempio di risoluzione di un nome simbolico in modalità iterativa
Resource Record: 	NAME - VALUE - TYPE - TTL
Caching con il tempo di vita dell'informazione (TTL) per pulire memorie da info obsolete.
Type: esplicita utilizzo del DNS
	A -> 	Name è il dominio di un host e value è l'indirizzo IP
	NS ->	Name è domain e value è il nome di un server che può ottenere le informazioni relative al name
	CNAME -> name è un alias per un host il cui nome canonico è in value
	MX ->	name è un mail domain o alias, value 

Come aggiungere un dominio nella rete DNS? Con i DNS registrars
Esperimenti con dig
Meccanismi di load balancing per DNS
CDN (content distribution network [io lo ricordavo come content delivery network])
	Nasce come soluzione al problema di gestire in maniera efficiente tanti contenuti verso tanti utenti molto lontani gli uni dagli altri
	La mappatura è fatta attraverso un server DNS

Applicazioni peer-to-peer
	Il primo più famoso era napster
	Protocollo distribuito ma registro centralizzato
	gnutella non ha nessun server centrale, protocollo di pubblico dominio, client diversi
	bittorrent: i tracker tengono traccia dei peer che partecipano ad un torrent. i file sono divisi in chunk
		meccanismo di richiesta dei chuck partendo dai più rari
/**********/
Lunedì 18 marzo 2019 - 1mo laboratorio

Daniele Moro è il responsabile laboratorio
6 lezioni 3 prima la prova in itinere, 3 dopo
le prime 3 python, le altre 3 con Cisco IOS CLI 

2 modalità 
	-> creare file di testo ed eseguirlo con il comando python script.py
	-> usare la shell interattiva chiamando python

questa lezione la trovi a lab/20190318.py

/**********/
Giovedì 21 marzo 2019
Il livello di trasporto - Cap.3
UDP, TCP, controllo di flusso, controllo di congestione
Su questa parte ci sono 2 laboratori (programmazione socket
Il servizio di trasporto instaura collegamento tra le applicazioni su host remoti
Rendono trasparente il trasporto dei messaggi alle applicazioni
È presente solo nei terminali della rete
Cosa fa? Multiplazione e demultiplexing
	Più applicazioni che condividono uno stesso indirizzo IP possiedono diverse porte (lungh. fissa 16 bit)
	Divisi in 3 parti: 
		Well-known ports (0-1023): spesso lato server
		Porte registrate (1024-49151): assegnate a specifiche applicazioni poco diffuse rispetto alle well-known
		Numeri dinamici  (49152-65535): usate per la multiplazione nei client
	Connessioni in parallelo sfruttano multiplazione per aprire più connessioni
Servizio di buffering
	Il sistema operativo crea due buffer (in entrata e in uscita) per ciascuna porta creata
	Vale sia per i client che per server
Servizio di rete non è affidabile (best effort). Il servizio di trasporto fornito può essere di vari tipi
	- trasporto affidabile (messaggi consegnati in ordine corretto)
	- trasporto non affidabile
	- trasporto orientato alla connessione
	- trasporto senza conn.
Nella suite IP sono definiti 2 protocolli: UDP e TCP
UDP trasmette e basta senza controlli; TCP regola la velocità di trasferimento in base alla ricezione e della rete
UDP (User Datagram Protocol)
	È il più semplice tra i due. Aggiunge ad IP solo mux/demux (indirizzamento porte) e CRC.
	Header corto (8 byte) con poche informazioni
	Minor latenza, più semplice e leggero.
	Il checksum (controllo di errore) (in UDP è a 16 bit) viene calcolato considerando l'header UDP, uno pseudo-header IP ed i dati.
		Funziona così: le informazioni vengono divise in blocchi di 16 bit. Il campo checksum è lasciato a 0. Poi si fa la somma binaria di tutti i blocchi in complemento a uno.
		In ricezione si complementa il risultato della checksum e deve venire zero.
	Prova cattura wireshark
Trasporto affidabile
	Il collegamento ideale è ricevere la stessa sequenza di trasmissione nello stesso ordine correttamente
	Protocolli di ritrasmissione (canale di feedback, la comunicazione deve esser bidirezionale)
		Obiettivo: integrità del messaggio/pacchetto, ordine sequenza, no duplicazione
		Ciascuna trama ricevuta va riscontratapositivamento con un messaggio di ACK
		A volte l'errore può essere segnalato con un NACK
		La mancanza di ACK o la presenza di NACK segnala la necessità di ritrasmettere
		La procedura di ripete finché la trama viene ricevuta correttamente
		Controllo di integrità e recupero d'errore vengono usati da TCP.
			I pacchetti possono andare persi a livello di rete (pacchetti scartati in coda)
		Meccanismi usati: timeout e finestra di trasmissione
	Il protocollo "stop and wait"
		utilizza solo l'ACK e un contatore di timeout.
		Funzionamento corretto solo se timeout>=2*tau+Tack
		Serve la numerazione dei pacchetti (SN, #sequence) e degli ack (RN, #request). COsì facendo si evitano i duplicati e ack verso pacchetti corretti.
		Efficienza del protocollo
								     T               1
		     	 EFFICIENZA  = -----------  = ---------------
							   T+Tack+2tau    1+Tack/T+2tau/T

		efficienza è bassa se T<<tau, quindi non adatto a situazioni con alto ritardo di propagazione e/o elevato ritmo di tx.
		Protocollo utilizzato perché funziona bene su half-duplex. Bene su distanze brevi
	Il protocollo Go-Back-N
		Variante dello stop and wait.
		Si inviano un numero max di pacchetti N (finestra). Se non ho ricevuto un pacchetto, si ritrasmettono tutti quelli non ricevuti a partire dal primo perso (max N pacchetti)
		La finestra è sempre di N pacchetti ma è una sliding window e si muove a ritmo degli ack ricevuti.
		Se non ci sono errori la trasmissione non si ferma mai (100% efficienza).
		I pacchetti fuori sequenza vengono scartati. [Oggi esiste anche la variante che accetta pacchetti fuori sequenza]
		Link applet che simula la connessione a pagina 34 delle slides.
		Il riscontro (ACK) può essere collettivo, cioé non individuali che riguardano un solo pacchetto ma relativo a tutti i pacchetti precedenti.
		Dimensionamento della finestra
			La finestra ottimale coincide con il RTT (round trip time) (=T+tau+Tack+tau)
					             T+Tack+2tau
			numero minimo di N = -----------
								   	  T
			(Sincronismo degli ack dice il ritmo con cui vengono ricevuti, in caso normale =T. Sono un indicazione del tempo di trasmissione che stima la capacità del collo di bottiglia della rete)
			La finestra può essere dimensionata in byte, bit, secondi, ...
			Si complica il dimensionamento se non si conoscono i tempi di propagazione (tau), per esempio quando i tempi di attraversamento sono variabili oppure i pacchetti sono di lunghezza variabile
			Rimedi:
				fare la finestra grande. Svantaggio: in caso dierrore aumenta il ritardo e ritrasmissioni inutili.
	Uso del NACK
		Può abbreviare i tempi di ritrasmissione.
		Ma se tra le informazioni corrotte c'è l'indirizzo sorgente? Il NACK va ad un indirizzo a caso.
		Se arriva un pacchetto fuori sequenza (es. arrivano l'1 e il 3) invio subito il NACK 2. Tale cosa consente una ritrasmissione veloce
		ACK ripetuto ha la stessa valenza di un NACK. TCP usa l'ACK ripetuto.
	Go-back-N FULL DUPLEX
		Il meccanismo di finestra mobile può essere fatto da entrambi i lati. Quindi entrambi gli host trasmettono dati e ack in senso opposto.
		Quindi nell'header del pacchetto esiste il numero di sequenza ma anche il numero di ack in direzione opposta
		Generazione del numero di sequenza e mantenere una variabile con il n SEQ successivo e un'altra var con dentro l'ACK da convalidare
		Si mantengono aggiornate queste 2 variabili e usate ogni volta che arriva un pacchetto nuovo
/**********/
Lunedì 25 marzo 2019
Il secondo laboratorio è lunedì prossimo
	Go-back-N e piggy backing (slide 40)
		i sequence n e gli ack (rn) sono inseriti nello header del pacchetto
		RN assume il significato di prossimo pacchetto atteso
	Regole go back n trasmettitore:
		N -> dim.finestra
		Nlast -> ultimo riscontro ricevuto
		Nc -> numero corrente disponibile per pacchetto in trasmissione
		regole:
			ogni nuovo pacchetto da trasmettere ha un numero di sequenza. Se è >=Nlast+N, viene messo in attesa, Altrimenti viene assegnato Nc, Nc viene incrementata di 1, il pacchetto si invia e per ogni riscontro si aggiorna Nlast = Nc
		In caso di scadenza del timer, la ritrasmissione riparte da Nlast
	Logica ricevitore:
		Se ricevo un pacchetto SN=RN, inoltro ai livelli superiri e RN=Rn+1
		Ogni tanto manda al TX RN
	Schema Go-back-N full duplex senza errori

	Necessità di inizializzare i numeri SN e RN e un numero di tempo da quando si inizia a contare e scambiarsi info.
	L'inizializzazione della variabile si fa ad un numero casuale per evitare qui pro quo.

Controllo di flusso a finestra mobile
	Buffer d ricezione limitato a W posizioni (numero posti liberi nel buffer) lato ricevitore
	Ritmo di assorbimento dell'utente arbitrario
	Obiettivo: regolare il ritmo di invio per evitare che pacchetti vadano persi perché trovano il buffer pieno
	
	Sliding window flow control
		Se unito al go-back-n fa in modo che i pacchetti vengono inviati in base alla disponibilità del ricevente sia in velocità che nel buffer regolando la finestra di trasmissione
		Esempio di uso del campo W
		a volte il ricevitore mente per avere delle reazioni diverse dal trasmettitore
	
Adesso guardiamo qualche esercizio del protocollo di ritrasmissione
/**********/
Mercoledì 27 marzo 2019

Protocollo TCP (RFC 793 (1981), RFC 1122(1989) e successive implementazioni)
Assicura il trasporto affidabile (sequenza corretta e senza errori e perdite di dati)
È possibile costruire applicazioni con trasferimenti senza errori e ha semplificato il modo di progettare le applicazioni.
Meccanismi di controllo di velocità e di congestione
È alla base della net neutrality (tutti i flussi sono trattati equamente, soprattutto nella condivisione dello stesso link)
Prima la rete era controllata dall'interno
Il TCP è connection oriented, cioè ha una fase preliminare allo scambio dei pacchetti (3-way-handshake)
Le connessioni TCP si appoggiano su una rete connectionless. Conn.TCP sono full-duplex (scambio di dati da ambo le parti) che può essere definito peer-to-peer perché il formato dei pacchetti è lo stesso in ambo i versi
(half-duplex = la connessione è bidirezionale ma se trasmette uno l'altro deve stare ad ascoltare e poi trasmettere, tipo walkie-talkie)
Il TCP accetta uno stream di byte, inseriti in un buffer. TCP poi riempie i segmenti in uscita. I segmenti hanno dimensioni variabili (con una lunghezza massima concordata).

Per la numerazione dei byte e riscontri i meccanismi di ritrasmissione somigliano al goback-N
	Ogni byte è numerato e ha un numero di seq.;
	segmenti formati da gruppi di byte
	dimensioni delle finestre in byte
	Nell'header del segmento TCP è trasportato il numero di sequenza del primo byte del segmento e il primo+1 delle ack
Campi dell'header
	Source e destination port (16 bit ciascuna);
	Sequence number e acknowledgment number (32 bit ciascuno);
	16 bit di flag (1° è HLEN, lungh.header diviso 32 (lungh.min. = 20B; l.max = 40B)), 16 bit di window per il controllo di flusso;
	checksum (16 bit) e urgent pointer (16b)
	Options e padding (max 20 byte) servono per opzioni e padding per raggiungere una dimensione divisibile per 32 bit
	---fine header---
	Campo dati di circa 1460-1480 byte per farlo entrare su frame ethernet

	I FLAG (1 bit ciascuno)
	Il flag urgent dice a tcp di separare i dati urgenti dal resto che permettono di avere un flusso di controllo parallelamente ad un flusso dati (utilizzo poco frequente)
	Il flag ACK vale 1 se il campo ack numer è valido, 0 se non è valido. normalmente lo è ma all'inizio (3W-Handshake)non è così
	PUSH (PSH) forza l'invio delle informazioni il prima possibile (risultato pacchetti piccoli)
	RST reset è per terminazione brusca della connessione, non è una bella cosa perché può creare problemi di inconistenza di stato nelle applicazioni. Putroppo è usato e il programmatore deve prevedere un timeout nel caso in cui la connessione resti appesa
	SYN. Se=1, il #Seq è il primo della connessione. Con questo si fanno gli attacchi DDoS inviando pacchetti con SYN in massa
	FIN serve per chiudere la connessione in modo soft
Opzioni
	No-operation e end of option servono come padding
	MSS Maximum Segment Size
		Val.min di default è 536B, MAX 65535B. Definisce la dim.max del segmento usata nella connessione TCP. Decisa dal mittente durante dla fase di setup.
	Window scale - Fattore di scala della finestra
		Default 1 ->misuriamo in byte, altrimenti prendo gruppi di byte pari a 2^fattore di scala.
		Questo consente di esprimere con 16 bit dei numeri più grandi
	...
	http://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml
Servizi per porte note
Setup delle connessioni
	Prima del call setup le applicazioni sia client che server devono comunicare con il software TCP
	1) I server sono sempre in ascolto, i client si attivano quando vogliono.
	Demone in ascolto sulla porta è il PASSIVE OPEN (server) e aspetta che qualcuno si connetta sulla porta.
	2) Il client invece effettua un ACTIVE OPEN, effettuando una connessione
	3) il client TCP manda un messaggio con SYN=1 e scrive nel #seq un num. casuale. Eventualmente indica anche MSS e window scale
	4) Il server risponde con un messaggio con flag SYN=1 e ACK=1. Invia a sua volta un #seq. casuale e fa l'ack della richiesta del SYN del client.
	5) Pacchetto di ACK=1 inviato dal client verso il server. È il primo, un ACK puro, si inviano anche MSS e Window scaling. Dopo questo pacchetto la connessione si considera aperta
	Quasi sempre nel pacchetto di ack puro vengono inseriti i primi dati trasmessi dall'applicazione

	Lato server una volta che la connessione viene aperta, deve essere gestita (a volte forking)
	Lato client niente di che

	Chiusura connessione è in modo asimmetrico (prima da un lato, poi dall'altro)
	Tear down
	Client invia FIN=1; server risponde con una ACK=1 e invia tutti i pacchetti mancanti; server invia FIN=1; client risponde con un'ACK. Connessione chiusa.
	Cattura wireshark TCP
	C'è anche il timestamp 1322764305
	
	Implementazione del controllo di flusso.
	Lato ricevitore.
		Receiver window (RCVWND): spazio del buffer in ricezione disponibile per ricevere nuovi dati (mantenuto dal TCP in una variabile)
		Si estende dall'ultimo byte inoltrato dall'applicazione fino alla fine del buffer
		Il buffer di ricezione può riempirsi acnhe per congestione nel SO del ricevitore
		La dimensione di RCWND è segnalata in ogni segmento inviato dal ricevitore al trasmettitore.
		Quando il buffer si svuota, la finestra si sposta in avanti
	Lato trasmettitore
		Send window SNDWND è una parte inutilizzata del buffer che rappresenta i byte che possono essere trasmessi senza attendere ulteriori riscontri
		Il trasmettitore tiene un buffer di trasmissione che tiene traccia dei dati trasmessi ma non ancora riscontrati e della dim della fin del ricevitore.
		Il bffer di trasmissione parte dal pirimo byte nn ricontrato all'estremo della finestra del ricevitore
	
	Problema della finestra 
		Silly window syndrome - lato ricevitore
			il ricevitore è lento e legge pochi byte alla volta. Quindi chi trasmette invia pacchetti piccoli. Problema: a volte lo header occupa troppo spazio rispetto ai dati
			Soluzione è l'algoritmo di Clark: il ricevitore mente al trasmettitore e indica una finestra nulla finché il buffer del ricevitore non si è svuotato per metà o per una porzione almeno pari al MSS
		Silly window syndrome - lato trasmettitore
			L'applicazione genera byte molto lentamente e segmenti molto piccoli man mano che vengono prodotti

		Soluzione: algoritmo di Nagle: i primi pacchetti piccoli, quelli dopo grossi sufficientemente per riempire un MSS oppure invia subito quando riceve un'ACK
	
	Funzione PUSH
		
	Dati URGENT
		->FTP utilizza una serie di comandi inviati (CONTROLLO) parallelamente all'invio e alla ricezione dei file (DATI) sfruttando urgent
	Controllo di errore in TCP 
		È simile a quello del Go-back-N con timeout.
		Differenze: TCP mantiene i pacchetti ricevuti fuori sequenza
	Gestione del timeout
		Questo dipende dal RTT: se il server è vicino è diverso se il server sta distante
		Problemi: se RTT lungo e timeout troppo piccolo, ritrasmissione troppo frequente, bisogna avere pazienza. Timeout troppo lungo impedisce recupero veloce.
		TCP misura il RTT dinamicamente.
		Stima del RTT attraverso gli algoritmi di Karn e Jacobson. (empirico)
			Stima del valor medio sulla base delle misure. Usiamo quello smoothed di RTT:
				(i)
			SRTT    = (1-alfa)*SRTT + alfa* e altre cose che non o fatto in tempo a  copiare

			Caloclo della deviazione (DEV) = |RTT^i-SRTT^(i-1)| e calcolo della deviazione smoothed

			TIMEOUT = SRTT + 4*DEV
			All'inizio il timout è 1 secondo.
			Dopo una ritrasmissione sarebbe meglio passare all'algoritmo di Karn.
			RTT non viene aggiornato, iltimeout è moltiplicato per un valore fisso (2), il timeout cresce fino ad un max., dopo un numero max di ritrasmissioni la conn. è chiusa
			Timer di PERSISTENZA: ??? da recuperare le slide
				se il destinat
				per evitare questa situazione si usa un timer di p. che viene attivato quando arriva un segmento con finestra nulla
				se il timer di p. scade viene inviato un piccolo pacchetto sonda

/**********/			
Giovedì 28 marzo 2019
Controllo di congestione, delegato al TCP
	obiettivo: regolare il traffico senza il vigile, ognuno si regola da solo (controllo end-to-end).
	(ECN - Explicit Congestion Notification, ultima trovata per il controllo di congestione)
	aggiungiamo delle variabili: la congestion window (CWND). Ogni istante vengono confrontate la CWND e la RCVWND, quella minore trale due è utilizzata.
	CWND si basa sulla velocità sulla banda di rete. (è più difficicle saperlo perché la rete non collabora)
	La ricerca della velocità ideale si basa sui tentativi effettuati. Si aumenta la velocità finché la velocità è troppo alta.
	A quel punto scadrà un timeout e ci sarà un evento di congestione = perdita dei pacchetti)
	Meccanismo basato su 2 meccanismi: slow start e congestion avoidance
	Per decidere quale dei due utilizzare si usa la variabile slow start treshold (SSTRESH).

	Slow start:
		Si parte lentamente con l'invio di 1 segmento di dimensione massima (1).
		Ogni volta che arriva un ACK, questo valore viene incrementato di 1. (crescita esponenziale)
		Parte un pacchetto e torna un ACK. Trasmetto 2 pacchetti e arrivano 2 ack. Ciascuno di questi 2 ack genera 2 pacchetti a sua volta (tot. 4). Poi 8, 16, 32, ...
		
		L'incremento può andare avanti finché: evento di congestione, CWND<SSHTRESH, CWND<RCWND
		Insieme alla finestra aumenta anche il ritmo di trasmissione stimato così:
		R = CWND/RTT in bps
	
	Limitazioni: collegamento in uscita dal dispositivo oppure in uscita dal router
	Un link è congestionato anche quando la somma dei ritmi di trasmissione dei flussi che lo attraversano è maggiore della sua capacità
	___
	\   R  > C
	/__  i
	 i

	Scade un timeout di ritrasmissione.
		Il TCP pone CWND a 1*MSS.
		Si pone SSTRESH al massimo tra 2*MSS e FlightSize/2 (che è il numero di pacchetti trasmessi e mai tornati indietro. Spesso FlightSIze è pari all'ultima finestra di congestione
		
	Come risultato se CWND è minore di SSTRESH si entra in slow start.
	Il TX trasmette tutti i segmenti andati persi (Go-back-N)
	Quando CWND >= SS treshold passo a CONGESTION AVOIDANCE
	
	Congestion avoidance (incremento frazionario)
		Si incrementa la CWND di 1/CWND ad ogni ACK ricevuto.

		La finestra continua ad aumentare lentamente (linearmente con coeff.angolare piccolo)
		
	Meccanismo del TCP per quando si è a regime
		\-> Fast retransmit e fast recovery.
		Fast retransmit: quando perdi un pacchetto, contrariamente al go-back-N, fa così.
			Quando un pacchetto viene perso, il contatore ACK del ricevitore non è aggiornato. La terza volta che TX riceve lo stesso valore di ack dal ricevitore, TX interpreta questo come un NACK e procede a reinviare il pacchetto perso. Dopodiché continua ad inviare la sequenza di byte nella coda.

		Il fast recovery consiste nel portare la congestion window NON più a 1 BENSÌ a quello di prima del timeout diviso 2.
		L'andamento che vedo in rete è tipo così: /|/|/|/|/|/|/|/|/ a dente di sega 
		Noi ci fermiamo a questa prima versione del TCP, che porta il nome di una località balneare, il terzo si chiama vegas

TCP e sistemi operativi
	la versione base è Tahoe, quella di questo corso.
	Per Windows abbiamo:
		Reno / New Reno
		SACK
		ECN
		F-RTO
		CTCP
	Per Linux:
		BIC: Binary Increase Congestion control (fino alla 2.6.18)
		CUBIC = quella più usata (da 2.6.19 a 3.1)
		PRR: Proportional Rate Reduction (dalla 3.2)
	Per MacOS:
		MacTCP(fino a 7.5.1) e Open Transport(dalla 7.5.2 alla 9.2.2)
		CUBIC (dalla 10.10) e ECN (dalla 10.11 in poi)

Condivisione equa delle risorse

Flussi grandi e flussi piccoli TCP su internet
Elephant e Mice flows. In alcune versioni i flussi elefanti vengono spaventati dai flussi topolino
/********/
Mercoledì 3 aprile 2019
Esercizi sul livello di trasporto
Es.1

Canale: 1Mb/s
tempo di propagazione (tau) = 250
(L) lunghezza delle trame = 2000 bit
    L    2000
T = _ = ______ = 2*10^3 s = 2ms
    C   1*10^6

RTT = T+2*tau = 502 ms
Per il GO-BACK-N: dimensionare la finestra minima per max efficienza
Se N*T>= RTT, allora N >= RTT/T = intero superiore di[502/2] = 251
Nel caso STOP and WAIT calcolo efficienza max
N = 1
q = T/RTT = 2/502 = 1/251 (inverso della finestra GO-back-N)

Es.2
tau = 24* T
F = 1000 pacchetti
Tack = T
(non dato ma T di timeout (Tout) = 100*T)
?= n di pacchetti trasmessi inutilmente se W = 100 (lungh.finestra) quando
	a. si sbaglia il primo pacchetto del file
	b. si sbagliano il primo e il 100esimo pacchetto del file
	c. si sbaglia l'ACK del primo pacchetto del file
	d. si sbaglia l'ACK del prim e del 100esimo pacchetto del file
a. dopo avere inviato 100 pacchetti, riprende la trasmissione regolare dal primo, quindi il numero è 100
b. 100 come prima perché una volta scaduto il primo, viene ritrasmesso tutto da capo e il 100esimo viene recuperato nella prima ritrasmissione
c. non succede nulla perché l'ack è cumulativo e quando arriva il secondo pacchetto convalida anche il primo
d. non succede niente, vedi sopra + 101esimo

Esercizio 3:
errore sui pacchetti: 1/10
errore su ack: no
timeout minimo è pari al RTT
calcolare l'efficienza in numero di pacchetti corretti sul totale
9/10
Se il tempo di propagazione tau = n*T e Tack=T, calcolare efficienza trasmissiva temporale totale.
      9T          9T
n=---------- = ---------   n è la lettera eta greca
|  10(2T+2nt)   20T(1+n)   |

Esercizio 4:
tau1 = tau2 = 500 microsecondi
C1 = 100 Mbps, C2 = 200 Mbps
F = 1250 MB diviso in pacchetti con L = 10'000 bit con header trascurabile

calcolare il tempo in cui si riceve l'ultimo bit nei seguenti casi:
	1) i pacchetti sono trasmessi alla max velocità
	2) 
	3)
1)
     F    1250*8*10^6
n = --- = -----------  = 10^6 bit
	 L      10'000

      L     10'000
T1 = --- = -------- = 100*10^-6 = 100microsec
     C1    100*10^6

T2 = L/C2 = 50 microsec

Ttot = 10^6+*T1+T2+2tau = 100,0015 s
2) Utilizzando stop and wait end-to-end e Tack = T
RTT = 2*(T1+tau1+T2+tau2) secondo quanto scritto sul testoh!
RTT = 2,3 ms
Ttot = 10^6*RTT - RTT/2 = 2300s - (0,0023/2) 
3)stop and wait applicato su ciascun collegamento separatamentea
RTT1 = 2T1+2tau = 1,2ms
RTT2 = 2T2+2tau = 1,1ms


siccome RTT2<RTT1 quando arriva il pacchetto posso andare avanti 
Ttot= 10^6 * RTT1 - (RTT1/2) + (RTT2/2) = 1200s - 0,6 + 0,55 = 1199,99995s

Esercizio 5:
STOP and WAIT. Difficoltà è nella dimensione dell'ultimo pezzo di file
Idem es.6
se viene un numero frazionario prendere intero inferiore e poi calcolare
c'è anche lo header del protocollo

Esercizio 7:
Due rack A e B comunicano tramite link (C) = 10Gbps di lunghezza 16m in F.O
File (F) = 375 byte direzione A->B.
Usiamo GO-back-N con queste caratteristiche:
Lack = 10B
Lfmax = 60B dei quali 10B di header
Tempo di elaborazione dei nodi trascurabile;
Ampiezza finestra (Ws) = 4
Timeout = 3s

Calcolare:
	a) tempo di trasferimento Tgbn del segmento dati
	b) throughput dati effettivo THRgbn della connessione
	c) dimensione minima W's della finestra di trasmissione per cui si raggiunge la eta(max) = efficienza massima

n = intero inferiore(F/Dfmax) = 7
Dflast = 375 - 7*50 = 25B =	200b
Llast = H+Dflast =    35B =	280b

Tfmax = Lfmax/C = 48ns
Tflast = Lflast/C = 28ns
Tack = Lack/C = 8ns
tau = Llink/(2*velocità luce/3) = 80ns
RTT = Tfmax+2tau+Tack = 48+8+160 = 216 ns
NTfmax = 4*48 = 192 ns
a)
	Ttot = Tfmax+tau+Tack+tau+3Tfmax+Tflast+tau+Tack+tau
		 = RTT+3Tfmax+Tflast+Tack+2tau= 556ns
	THR = 375 * 8 / Ttot = 5,4 Gbps
b)         RTT      216
	W's =-------- = ---- = 5
	      Tfmax      48

	Ttot = 7*Tfmax+Tflast+2tau
	THR = 375 * 8 / Ttot = 5,64 Gbps

Esercizio 8
A->B
C = 160 Mbps
d = 4000 km
Ws = 5
n = 10
Lmax = 125'080 B = 1'000'640 b
Lflast = 80'080 B = 640'640 b
Lack = 80 B = 640 b

tau = 5microsecondi al kilometro = 20 ms
Tmax = Lmax/C = 6,25 ms
Tlast = 4 ms
Tack = 4 microsecondi

RTT = Tmax+Tack+2tau = 46,25 ms 
/*********/
Lunedì 8 aprile 2019
Lezione di laboratorio




/**/
Lunedì 29 aprile 2019
Il livello di rete
È diviso in due piani:
	- Piano dati (Data Plane): IP. Contiene informazioni dei piani superiori.
	- Piano di Controllo (Control Plane): ICMP, ARP, RARP, OSPF, RIP. Non contengono informazioni generate dall'utente.
Funzioni fondamentali:
	Indirizzamento: identificazione univoca dell'interfaccia di rete di un host/router.
	Inoltro/forwarding: Funzione locale con cui il router trasferisce i pacchetti da un ingresso ad un'uscita, leggendo la tabella.
	Instradamento/routing: processo che determina i percorsi dei pacchetti dalla sorgente alla destinazione. Globalmente è svolto dagli algoritmi do routing
Data plane a livello rete
	La strada che seguono i pacchetti IP, dall'incapsulazione alla consegna al destinatario che spacchetta
	Caratteristiche: best effort e connectionless. I router hanno tabelle di instradamento con le quali decidono dove inviare i pacchetti. Potenzialmente i pacchetti potrebbero percorrere strade diverse tra sorgente e destinazione (in realtà dipendono dalle tabelle di instradamento).
Funzioni base di un router: leggono il valore di header e decidere dove inoltrare (inoltro). Algoritmo che crea ed aggiorna le tabelle di routing (controllo)(ottimizzato hw/sw)

Indirizzo IPv4: è a 32 bit raggruppato byte per byte divisi con un punto.
	Gli indirizzi IP non sono relativi alla macchina ma all'interfaccia di rete e anche alla rete per come è stata pensata.
	Ciascun indirizzo pubblico deve essere univoco. Ogni operatore di rete ha un set di indirizzi assegnati ad esso.
	IP addr diviso in due parti: netid (numero della rete) e hostid (numero assegnato all'interfaccia)
Indirizzamento CIDR (Classless Inter Domain Routing)
	Indirizzi flessibili introdotti in via definitiva dal settembre 1993. RFC 1517 - 1520.
	Viene introdotto il prefix length w.x.y.z/n per indicare la lunghezza di una rete.
	Es. 134.76.96.0/19 -> 2^(32-19) = 2^13 = 8192 indirizzi ip adiacenti da 134.76.96.0 a 134.76.127.255
	Questo sistema ha rivoluzionato il sistema classful che vedremo tra poco.
	Netmask = numero a 32 bit che indica quanti e quali bit sono assegnati al NetID. Viene indicata con una notazione decimale puntata.
	Se faccio l'operazione di AND bitwise tra netmask e indirizzo IP il risultato è la rete a cui appartine l'indirizzo
	Attenzione a non assegnare a due macchine lo stesso indirizzo IP.
	Il primo e l'ultimo indirizzo IP di una rete non sono assegnabili a degli host

	Blocchi di indirizzi speciali:
		/*Questi potrebbero essere etichettati in maniera sbagliata*/
		Classe A: 10.0.0.0/8
		Classe B: 172.16.0.0/16
		Classe C: 192.168.0.0/16
	Questi tre blocchi si possono utilizzare solo su reti private e sono riutilizzabili in tutte le reti private
	Broadcast limitato = 255.255.255.255. Viene inviato a tutti gli host della stessa rete del mittente
	Gli indirizzi che iniziano con dei bit a 0 vogliono riferirsi alla stessa rete. Esempio: 0.0.21.173/16 indica un host nella stessa retedel mittente
	0.0.0.0 indica se stesso quando non conosce il suo indirizzo
	127.x.x.x è l'indirizzo di loopback, quindi non esce mai dalla macchina
	Gli indirizzi IP sono assegnati da IANA (Internet Assigned Numbers Authority), dipartimento di ICANN. Amministra anche DNS root
	Esistono 5 entità locali per la assegnazione di indirizzi agli operatori di rete
	Gli indirizzi IPv4 sono esauriti
	Indirizzamento classful
		Classe A, B e C sono tagliati con l'accetta e hanno dei blocchi di dimensione fissa per il netID di 1,2 e 3 byte rispettivamente.
Subnetting
	Problema: reti IP troppo grandi. 
	L'indirizzo IP del politecnico era una classe B 131.175.0.0/16.
	NetID viene suddiviso ulteriormente, vnegono sottratti indirizzi per la parte di hostID e dati al subnetID.
	Esempio: ho una rete 128.134.0.0/16 dalla quale creare almeno 1000 sottoreti.
	2^10 = 1024 sottoreti aggiungendo 10 sottoreti. La nuova rete avrà 10+16 bit di host e 32-26 bit di host. La nuova netmask sarà 255.255.255.192

	Blocchi di dimensione diversa: subnetting a più stadi
	Variable Length Subnet Mask (VLSM)
	
/***/
Giovedì 2 maggio 2019
Inoltro dei pacchetti
	Con gli indirizzi IP assumiamo che tutti gli host siano collegati alla stessa rete (Inoltro diretto). È previsto anche intoltro indiretto
	Indirizzi IP e indirizzi MAC
	Come si capisce se si è sulla stessa rete? (inoltro diretto) se facendo l'and tra ip sorgente e netmask, stessa cosa per il destinatario
	Se l'indirizzo non appartiene alla stessa rete, il pacchetto passa al router, configurato inizialmente (default gateway, chepperò è un termine generico).
	Una volta arrivato al router, ci si basa sulle tabelle di routing per l'inoltro.
	Caratteristiche per l'inoltro:
		- destination base (ci si basa sull'indirizzo di destinazione)
		- nelle tabelle di routing per ogni rete di destinazione è indicato il prossimo router a cui inviare il pacchetto
	Nelle tabelle di routing sono indicati: netID, netmask e next hop.
	Rotta = riga della tabella
	Ulteriore riga (autoconfigurata) che indica l'interfaccia di uscita
	La netmask dell'indirizzo di destinazione non è nota globalmente, ci si basa quindi sulla netmask della rete
	Se non si può fare l'inoltro diretto, lo si fa indiretto (con la tabella).
	Destinazione di default esiste anche nei router ed è possibile farla compatibilmente con la topologia fisica del router 
	Se vengono trovate più rotte compatibili, si segue quella con il prefix length più lungo (longest prefix match).
	La rotta di default ha come indirizzo 0.0.0.0 e netmask uguale (0.0.0.0), il cui confronto dà esito positivo. È poi segnato il next hop.
	/*6666C@1337r*/
Il supernetting
	C'è il problema che se creo tante reti si riempiono le tabelle di routing, quindi bene tenerle corte.
	Se le reti sono contigue e potenze di 2, posso definire una unica riga che le copre tutte (aggiustando netID e netmask)
	Le tabelle di instradamento di ingresso sono di qualche decina di righe. Quelle degli ISP di 1mo livello, della propria rete sono centinaia di rotte. Quelli di trasnito centinaia di migliaia.

Il livello di rete: IP, ICMP, ARP, DHCP, NAT
	IP: connectionless packet-oriented, non affidabile, assegna un indirizzo universalmente riconosciuto.
	Frammentazione/defrag (solo IPv4): se il pacchetto IP è più lungo della dimensione del frame, si occupa di frammentare il pacchetto e poi di rimetterlo insieme una volta rrivato.
	Campo TTL (Time-to-live): è il numero massimo di passaggi tra router che un pacchetto può fare
	Header IP
		versione (4b), HLEN = header length (4b), TOS(DS) (type of service, 8b) serve per distinguere i pacchetti tra di loro, total length (16b).
		Fragment identification (16b) serve per capire i pacchetti frammentati, flags(3b), frag.offset (13b) per rimettere insieme i packets.
		TTL Time To Live (8b), Protocol per capire quale protocollo superiore si utilizzano, quindi mux/demux (8b), header checksum (16b).
		Source e destination address (32b each).
	Descrizione parti header
		TOS è diviso in DSCP ed ECN (quest'ultimo utilizzato a volte)
		Offset è il numero del primo byte / 8;
		Flags: (M)ore è pari a 0 solo nell'ultimo segmento; (D)on't fragment
		Opzioni (<40B) servono a fare testing, debug di rete, analisi di congruenza netmask, mini-sincronizzazione. Oggi non si usano più perché ci sono protocolli più efficienti che svolgono lo stesso lavoro.
	Struttura implementativa protocollo IP
	Tutti passano dal processing module
	Reassembly module è attraversato solo quando si arriva alla destinazione del pacchetto.
	Routing module e fragmentation è per l'invio del pacchetto e la frammentazione

	Control Plane: protocolli di gestione
		ICMP: internet control message protocol. Server per gestire messaggi di gestione di errore tra host e router. ICMP usa IP, quindi sta a livello 4 anche se è a stretto contatto con IP e ne utilizza le informazioni
			Messaggi di errore:
				Time exceeded (type 11)
					Codici di errore (0 lo invia un router, 1 dall'host destinazione)
				Destination unreachable (type 3) -> usually non ci sono router settati
					Ci sono codici di errore diversi: network unr., host u., protocolo u., ...
			Query
				Echo request/Reply (keep-alive) type 8, servono per diagnostica
					-> c'è un identificatore comune e un numero di sequenza
			
			Il protocollo non fa correzione di errori ma solo notifica. Il messaggio contiene lo header del pacchetto compromesso e i primi 8 byte dello stesso
			Redirect.
		Traceroute si basa sulle echo request e il TTL. All'inizio mette il TTL=1 e poi il router risponde, poi manda il TTL=2, eccetera...finché non arriva alla fine.
		Profo ci esorta a sperimentare.

/**/
Lunedì 6 maggio 2019
	Continuando nel control plane, trattiamo l'ARP, RARP e DHCP
		Address Resolution Protocol (ARP) consente di gestire la corrispondenza tra indirizzi IP e MAC.
		Sia host che router fanno uso di tabelle ARP. Se la macchina non trova l'indirizzo MAC della destinazione, viene inviato un messaggio broadcast di ARP-request.
		L'host proprietario dell'indirizzo IP cercato risponde in unicast (ARP reply) al mittente.
		Il messaggio broadcast ARP ha come indirizzo fisico di destinazione ff:ff:ff:ff:ff:ff (tutti bit a 1, come per IP); come indirizzo di sorgente possiede quello della macchina che l'ha richiesto.
		Non ha senso fare ARP request su altre reti/sottoreti.
		Nella ARP request ci sono gli indirizzi IP e MAC del mittente e del destinatario:
		ARP request:	IPmittente, MACmittente, IPdestinatario, MACdestinatarioA = 00:00:00:00:00:00 (perché sconosciuto)
		ARP reply = ARP request tranne per il MAC dell'allora destinatario, ora mittente, che inserisce il proprio
		Le tabelle ARP vengono tenute in memoria e dopo un po'sono cancellate se non vengono refreshate (di solito tempo breve umano)
		ARP reply gratuite servono per notificare quando cambia una corrispondenza IP-MAC e notificare la rete locale.
		
		RARP - Reverse ARP
		Dato l'indirizzo MAC, mi interessa sapere l'indirizzo IP. 
		Oggi è stato soppiantato da DHCP.
		Serviva per avviare una macchina senza disco, né sistema operativo, che veniva caricato tramite un server BOOT, il quale gli assegnava anche un indirizzo IP e gli passava il SO.
		
		DHCP - Dynamic Host Configuration Protocol (RFC 2131) è di livello 5 ed usa UDP
		Configurazione e fornitura degli IP centralizzata in un server.
		Le associazioni possono essere:
			Statica: stessi IP per gli host
			Automatica: automatizzata dal server
			Dinamica: l'insieme degli indirizzi IP è più piccolo degli host che possono utilizzarlo (mi sembra strano, leggi pagina wikipedia)
			(Secondo wikipedia allocazione dinamica = quella automatica MA assegna gli indirizzi in modo casuale al contrario di quella automatica che si ricorda di assegnare gli stessi indirizzi alle stesse macchine)
		Associazione dinamica: l'IP non è fisso ma dato in lease agli host, che devono rinnovarlo
		
		Come funziona DHCP?
			1) Il client invia un DHCP DISCOVER message nella rete con IP sorgente 0.0.0.0
			2) I server DHCP rispondono con un DHCP OFFER
			3) Il client accetta
			4) Il server invia la configurazione al client (IP addr, netmask, next hop, DNS server)
			5) Il client rinnova il lease
			6) Il client rilascia l'indirizzo assegnato con DHCP RELEASE

		DHCP relay: ci sono più server che ascoltano le richeste in locale e lo inviano ad un DHCP server in un altra rete. In quest'ultimo server ci saranno tutti i piani di indirizzi per tutte le reti. Quel server invia direttamente al mittente la risposta DHCP.
	
		Porte 68 (sorgente) e 67 (destinazione); IP sorgente: 0.0.0.0, IP destinazione è broacast (255.255.255.255)

Reti private e intranet
	(cenno storico ad Asynchronous Transfer Mode)
	La rete privata si può dividere in sottoreti
	Servizi offerti dalla intranet diversi da quelli su internet
	Indirizzamento privato
	DMZ - zona demilitarizzata
	
	NAT (network address translation) e proxy
	
	Indirizzi pubblici su una intranet stanno sul router semplice oppure su un proxy applicativo;
	Connessione tramite server proxy:
		intranet e internet scollegate a livello IP; funziona sia con indirizzamento pubblico che privato; il proxy parla con l'esterno con il suo indirizzo pubblico; occorre avere un proxy per tutte le applicazioni
	I proxy sono application gateway

	NAT: Network Address Translation
		->deve avere un pool di indirizzi pubblici disponibili
		Un pacchetto che ha un indirizzo privato che cerca di contattare l'esterno incontra il NAT nel router. Al livello 3, traduce l'indirizzo privato in quello pubblico e lo spedisce.
		Il server NAT deve ricordarsi delle corrispondenze (con delle tabelle) tra indirizzo interno ed esterno in ambo le direzioni. Di base (basic NAT) il primo pacchetto deve passare da dentro a fuori e poi si può andare in entrambi i versi.
		Outbound NAT = da dentro verso fuori
		La corrispondenza può essere statica o dinamica.
		NAPT(network address port translation) oppure PAT , protocollo con cui si traducono indirizzi di livello 3 e di livello 4.
		NAT bidirezionale, in cui il primo pacchetto può andare in ambo le direzioni.

		Caratteristiche comuni:
		- Transparent Address Translation
			associazione trasparente alle stazioni
			associazione statica (inefficiente) oppure dinamica(+ complessa)
		- Transparent Routing
			routing gestito in modo coerente all'indirizzamento
		- ICMP Packet Translation
			anche gli indirizzi IP in ICMP vanno mappati
		
		Associazione dinamica associa più indirizzi privati a meno indirizzi pubblici.(forse, questa non so es è giusta)
		Si fa uso di timer che devono essere sincronizzati con la fine della trasmissione
		Application Level Gateway
		Traditional NAT è outbound NAT. 2 sotto-tipi
			- basic NAT
				viene traslato solo l'indirizzo IP
				corrispondenza 1:1 tra indirizzo pubblici e privati
				può esserci un blocco quando si è in tanti a trasmettere verso l'esterno
			- NAPT (PAT)
				Viene traslata la coppia IP:porta (32bit+16bit)
				Molti indirizzi interno possono utilizzare lo stesso indirizzo esterno
				
		Bi-directional NAT
			Si può iniziare una sessione in entrambi i versi.
			Ad una macchina viene assegnato un indirizzo IP statico
			port forwarding
			dynamic DNS server

			NAT è problematico per IPsec e Applicazioni che trasferiscono IP o meccanismi di cifratura
/**/
Giovedì 9 maggio 2019
4) Reti parte C: algoritmi di instradamento
Agenda: instradamento in rete e cose.

Routing unicast: consente a due nodi non direttamente collegati di comunicare tra di loro (entità di livello 3)
Politica di routing (o algoritmo di routing) è quella che definisce i criteri di scelta del percorso dei pacchetti.
Protocollo di routing (ce no sono più di uno): è solo la parte che descrive lo scambio di messaggi tra i router. (anche se strettamente legato al modo con cui sono calcolate le tabelle di routing).
Routing e capacità. La capacità massima è data dal canale. Routing efficiente.
Il tipo di inoltro (forwarding) utilizzato da IP condiziona la scelta delle politiche di routing. (forwarding IP: basato su indirizzo di destinazione e con inoltro al next hop).
Questo implica che se più pacchetti che vengono da più sorgenti incontrano uno stesso router, tutti seguiranno lo stesso percorso. Spesso è poco efficiente se ci sono altre strade.
I percorsi per una destinazione comune sono un albero (sorgenti = foglie; radice = destinazione).
Principio su cui si basa il routing IP:
 - inviare i pacchetti sul cammino minimo verso la destinazione
 - la metrica su cui si calcolano i cammini minimi è generale
 - il calcolo avviene in modo distribuito dai router che si scambiano queste informazioni
 - nella tabella è indicato solo il router successivo

Caratteristiche dell'instradamento
Classificazione:
 - Instradamento senza tabella
 	- Random
	- flooding: mando il pacchetto su tutte le destinazioni
	- source routing: il genio della lampada fa sapere al pacchetto dove andare
 - Instradamento con tabella
 	- Fisso
	- Dinamico
 - Instradamento gerarchico

Con tabella: a distanza minima e richiede la definizione di una metrica sulla base di alcuni parametri
	Fisso: viene fatto in fase di progettazione; se c'è qualche inconveniente in rete non è in grado di adattarsi a quello che succede nella rete.
	[IP] Dinamico (o adattivo): la tabella varia nel tempo col cambiare della topologia della rete.
	
digrafo G(N,A)
 - N nodi
 - A archi (coppia ordinata di nodi) A={(i,j) i in N e j in N}
percorso: insieme di nodi
cammino: percorso senza nodi ripetuti
ciclo
digrafo connesso
digrafo pesato
lunghezza di un cammini

Dato un digrafo G(N,A) e due nodi (i,j), trovare il cammino di lunghezza minima.
Proprietà: se il nodo k è attraversato dal cammino minimo da i a j, il sottocammino fino a k è anch'esso minimo.
Problema con complessità polinomiale (poco complesso)

Problema pratico: abbiamo risposto per enumerazione (per disperati)
Com'è stata trovata la soluzione? Elencando tutti i possibili percorsi?
Come convincere il professore che è quello minimo?

Gli algoritmi che vediamo:
	- Algoritmo di Bellman-Ford
		Ipotesi: non ci sono cicli di lunghezza negativa; pesi sia positivi che negativi
		Scopo: trovare i cammini minimi da tutti i nodi ad un solo nodo e trovare i cammini minimi tra un nodo e tutti gli altri nodi.
		In cosa consiste?
		È un casino scriverlo e saperlo e saperlo spiegare.
		Condizioni di partenza: D(s)^h = 0; D(i)^0 = inf
		Iterazioni D(i)^(h+1) = min[Di^h, min(j)(D(j)^h + dji)]
		L'algoritmo termina in N-1 passi.

		L'algoritmo esiste anche in forma distribuita
	- Algorimo di Dijkstra
		Funziona soltanto se gli archi hanno tutti pesi maggiori di 0.
		Scopo: trovare i cammini da tutti i nodi verso un nodo 1
		Valori iniziali: P{1}, D1 = 0; D(j)^0 = d1j per ogni j =/= 1
		Etichette temporanee e permanenti
		Problema: non può essere distribuito, perché l'insieme P (etichette permanenti) è salvato da qualche parte e poi non può essere fatto in parallelo.

		Ci sono dei protocolli che distribuiscono informazioni topologiche
		L'algoritmo di Bellman-Ford ha una complessita O(N^3) mentre quello di Dijkstra di O(N^2), quindi quest'ultimo è più conveniente
		Rappresentazione grafo: con una matrice quadrata, liste concatenate
Informazione di instradamento globale e decentralizzata
	- Globale: tutti i router vedono la topologia completa della rete e hanno informazione sul costo per ciascun link. Tipico degli algoritmi "link-state"
	- Decentralizzata: tipico degli algorimi "distance vector", determinano la la tabella di routing scambiando informazioni solamente con i prossimi applicando un processo di calcolo iterativo.

Algoritmo "distance vector": usato in ARPANET dal 1969 al 1979
	- applica Bellman-Ford in maniera distribuita e riempie così la tabella di instradamento
	ogni nodo invia il DV periodicamente e se il risultato del ricalcolo differisce dal precedente
Algoritmo "link state" su ARPANET dal 1979
		
.....(ho saltato una lezione per malattia)...
Lunedì 15 maggio 2019
mi gira il cazzo e c'è quel coglione di laboratorio che sta cercando di spiegare l'interfaccia di packet tracer ma mi può benissimo succhiare le palle col risciacquo.

Usiamo i router 2600 modulari e di fascia media
/**/
Giovedì 16 maggio 2019
Rete parte D + kahoot

Internet è suddiviso in autonomous systems (AS), il dovere del cui è quello di fornire il collegamento
Un AS è una porzione di rete gestita dalla stessa autorità. Ci sono gli interior gateway e gli exterior gateway.
IGP ed EGP (interior/exterior gateway protocol)
Routing domain è porzione di AS con router che appartengono a più domini.
Ridistribuzione delle informazioni di un router di frontiera su più domini
IGP: (distance vector) RIP v1, v2
	 IGRP proprietario di CISCO
	 (link state) IS-IS
	 OSPF

EGP: (path vector) BGP (Border Gateway Protocol)

Routing Information Protocol: RIP v1, progettato nel 1982 e standardizzato nel 1988
Distance vector, usa Bellman-Ford per il calcolo dei cammini minimi, protocollo distribuito
Metrica: numero di hop
Limitato a 16 hops
I pacchetti sono incapsulati in UDP con port number 520 e IP destinazione 255.255.255.255

Pacchetto RIPv1 contente info
Header: command, version, reserved.
		family, padding
		network address
		padding
		padding
		distance
(padding = tutto a zero)

Messaggi di richiesta possono essere di tutte le destinazioni oppure di un solo IP
Max 25 richieste, poi se ne invia un altro
Tempi:
una rotta si invalida dopo 180 s
routing update ogni 30 s
triggered update

Limitazioni: metrica con hop count, nodi con diametro max 15, reti omogenee, convergenza lenta dovuta ai timer lunghi, no netmask

RIPv2 (RFC 1723)
Aggiunta autenticazione, info sulla connettività (indicazione esplicita del next hop, route tag), classless routing (subnet mask), multicasting: 224.0.0.9

OSPF (RFC 1247 e succ.): protocollo di routing carrier-grade
	Protocollo link-state con Dijkstra in ogni nodo
	supporta il routing gerarchico
	metrica generica
	utilizzo protocollo di hello per monitorare lo stato dei vicini
	Trasportato direttamente su IP (protocol 89), ma deve implementare funzioni di livello di trasporto, come ACK
	Molte tipologie di messaggi scambiati
	Supporta auth
	supporto percorsi multipli verso la destinazione
Tipi di collegamento in OSPF: punto-punto, reti con 1 router, reti con più router.

BGP è il collante dell'intera internet (è lo standard de facto per i protocolli EGP).
Permette agli AS di annunciare la propria presenza in rete ed essere raggiunti

Non più distance vector ma path vector. Attributi di tipo generale, contengono una serie di informazioni ma obbligatoriamente contiene il percorso per arrivare alla destinazione.
Utilizza connessione TCP (porta 179), autenticazione dei router.
Messaggi: OPEN, UPDATE, KEEPALIVE, NOTIFICATION
Policy based routing sono regole che impediscono il traffico da e/o verso una certa destinazione, oppure che impediscono l'inoltro tra due punti

Agli AS viene assegnato un numero univoco da IANA.

/**/
Lunedì 27/05/2019

Panoramica su EIGRP, ma lo abbiamo solo accennato, non abbiamo fatto l'esericio.

NAT: Network Address Translation
Traduzione degli indirizzi privati verso l'esterno dal router, che sostituisce l'indirizzo privato di sorgente con il suo
1)
COMANDI: definire le interfacce se sono inside oppure outside con IP NAT INSIDE/OUTSIDE.
2)Definire un pool di indirizzi che possono essere usati con ip address e wildcard
ip access-list nomelista permit ip_network_address wildcard

3) associare il nat alla lista di prima
ip nat inside source 

/*Mercoledì 29/05/2019*/
Tecnologie di reti locali, ethernet, WiFi

Tecnologie di reti locali (LAN)
	IEEE è l'organismo di standardizzazione di reti locali con 802 Working Group
	LLC e livelli superiori sono condivisi da tutti gli standard di protocolli di comunicazione; MAC e livello fisico differiscono.
	Ethernet è stato progettato da Xerox nel 1976, poi standardizzato da IEEE 802.3 WG.
	Nella sua prima versione il mezzo fisico adottato era un cavo coassiale passivo (BUS) a cui si connettevano le stazioni mediante un transceiver.à
	Ethernet XBaseY:
		X: bit rate in Mb/s
		Base: trasmissione in banda base con codifica Manchester
		Y: lunghezza massima in centinaia di metri
	Ethernet 10Base5 (thick ethernet, cavo RG-213)
	Ethernet 10Base2 (thin ethernet, cavo RG-58)
	La topologia a bus è stata lentamente abbandonata in favore di una topologia a stella, grazie ad una macchina di rete chiamata HUB. Gli hub sono dei ripetitori di segnale a livello fisico.
	Quando arriva un segnale ad una porta, lo ritrasmette a tutte le altre porte
	Il mezzo trasmissivo cambia ed è rimpiazzato da doppini in rame (twisted pairs) (Ehternet 10BaseT)
	A fine anni '90 il rate di trasmissione viene aumentato da 10Mbps a 100Mbps con FastEhternet. In aggiunta ai twisted pair (100BaseTX), si iniziano a usare le fibre ottiche (100BaseFX). Con questo cambiamento lo hub viene sostituito con uno switch.
	Adesso anche gigabit eth, il prossimo passo è il terabit ethernet (fino ad oggi esiste il 400Gbps)

	Tipi di doppini in rame:
		UTP
		Cat 1: analog telephony line
		Cat 2: digital telephony line
		Cat 3: B=16MHz (Eth 10BaseT)
		Cat 4: B=20MHz ?????????????
		...
	Il connettore RJ-45 è diventato oggi lo standard per le reti con doppini
	Su ethernet si usano diverse coppie per trasmettere e per ricevere.
	Cavo diretto (straigth-through) o incrociato (crossed)
	Se connetto un PC ed uno switch le cose funzionano con un cavo diretto; se voglio connettere due PC serve un cavo incrociato.
	Questa cosa oggi potrebbe non servire perché le moderne schede di rete sono in grado di adattarsi
	
	Protocol stack
	OOO ->porte di passaggio
	LLC ->multiplexing
	O ->porta di passaggio
	MAC ->filtraggio e accesso multiplo
	O ->porta di passaggio
	PHY ->TX/RX CS e CD

	Esiste una verisone di ethernet che mette tutte queste cose insieme

	Trama ethernet:
	Sync(7B), Destination(6B), Source(6B), Type(2B), Data(46-1500B), FCS(4B)

	Type per multiplazione a più livelli, FCS è tipo CRC
	Indirzzi MAC: 48 bit (6B): i primi 3B sono relativi al costruttore, i restanti 3 identificano la scheda. Indirizzo broadcast è FF:FF:FF:FF:FF:FF (tutti 1).

	WiFi 802.11 è la versione wireless di ethernet.
	2 modalità: centralizzata e distribuita.
	BSS = Basic Service Set; AP = Access Point
	Centralizzata: i device non possono parlarsi tra di loro ma solo verso un access-point.
	Distribuita (modalità ad hoc): collegamenti diretti tra un gruppo di stazioni oppure peer-to peer tra i dispositivi.
	Il BSS è quello che si crea all'interno di una rete wireless; poi quando l'access point si connette alla rete cablata si viene a creare l'ESS (extended service set) tramite un sistema di distribuzione.
	L'AP fa store and forward e non è uno switch.
	Unico indirizzo di livello 2: sia ethernet che wifi utilizzano gli indirizzi MAC.
	Nel frame WiFi ci sono fino a 4 indirizzi per trama. I primi due sono sorgente e destinatario; la seconda coppia è formata da trasmettitore (attuale) e ricevitore (access-point)
	
Collegamenti commutati
	LAN commutate (switched)
	L'hub fa una ripetizione bit a bit e c'è una possibilità di collisione tra tutti quelli collegati.
	Lo switch fanno store and forward delle trame e, con lo store, evitano le collisioni. COmmutazione di pacchetto.
	Lo switch impara qual è la porta giusta dell'inoltro.
	Funzioni dello switch: filtering e relay.
	Filtering: se una trama ricevuta da LAN1 è indirizzata ad una stazione di LAN1, viene scratata
	Relay: se una trama ricevuta da LAN1 è indirizzata ad una stazione di LAN2, viene trasmessa su LAN2
	Inizialmente lo switch era chiamato bridge e serviva per mettere in comunicazione due hub
	Per stabilire se filtrare/instradare una trama si consulta una tabella di instradamento locale chiamata forwarding database (o FDB)
	A ciascuna porta dello switch è collegato un dominio che può contenere una stazione oppure una rete broadcast tradizionale (hub).
	Lo switch non invia più bit per bit ma trame.
	Transparent bridging.
	Le tabelle di switching sono compilate automaticamente, l'indirizzo dello switch non compare nelle trame, la presenza dello switch è completamente trasparente alle stazioni
	Gli algoritmi di bridging imparano automaticamente da quale porta si raggiunge una stazione grazie al fatto che la rete è topologicamente fatta ad albero.
	Autoapprendimento.
		All'inizio la tabella di switching è vuota.
		All'arrivo di ogni pacchetto viene registrato l'indirizzo sorgente e inserito in una riga della tabella di switching.
		Poi viene letto l'indirizzo di destinazione. Se l'indirizzo è in tabella si inoltra sulla porta corrispondente, altrimenti si invia in broadcast ovunque tranne che sulla porta da dove lo si è ricevuto.
	Validità della riga della tabella è di 300s
	Se la rete non è un albero succedono dei diastri, specialmente la BROADCAST STORM.
	Bastano due switch e due reti connesse ad anello per incasinare tutto.
	Si evita questa cosa con uno spanning tree. Da un grafo bisogna tagliare qualche ramo.
	Cioè la rete ha la sua topologia ma alcune porte vengono bloccate
	Una porta bloccata lascia passare i messaggi del protocollo di spanning tree ma non le trame dati.
	Esistono i pacchetti di spanning tree protocol, si elegge una radice, si calcolano i rami dell'albero.
	LAN completamente commutate.
	La modalità Ethernet full duplex consente la trasmissione sul doppino o fibra senza meccanismo di accesso multiplo (no CSMA-CD). Ciò consente la creazione di LAN completamente commutate, che costituiscono la soluzione usata universalmente oggigiorno.

	Bridge con tecnologie eterogenee (come ad esempio un AP wifi), che è connesso ad una rete ethernet.
	
VLAN
	Ad uno switch è collegata fisicamente una rete, ma a livello logico (non fisico) separo a piacimento la rete. Se una VLAN vuole comunicare con un'altra deve passare per un router.
VLAN port based.
	Le VLAN possono essere separate staticamente su base porta (solo reti ad un livello)
	Dominio di broadcast disgiunto per ogni VLAN, definito a priori assegnando le porte degli switch (access port) a VLAN diverse.
	Indipendente dalla configurazione fisica delle VLAN

	I pacchetti hanno una label scritta dentro al pacchetto IP.
	Un trunk è un link dove passano pacchetti di diverse VLAN.
	Lo switch si comporta come se ci fossero n switch, dove n è il numero delle VLAN create.
	
