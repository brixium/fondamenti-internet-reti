Appunti di fondamenti di internet e reti - prof.Antonio Capone
/*********/
25 febbraio 2019

Lezione introduttiva
antonio.capone@polimi.it	0223993449
subject #FIR
Ricevimento in Bovisa il mercoledì 8.30 - 10:00
VIA room wi-fi
room name: 172.26.13.31
Code 2238
Materiale all'indirizzo home.deib.polimi.it/capone/ e http://www.antlab.polimi.it/teaching-capone/fondamenti-di-internet-e-reti
Laboratorio con Ing.Moro

Libro di riferimento: J.F. Kurose, K.W. Ross
Reti di calcolatori e internet 
edizione Pearson

Altro materiale:
	- slide
	- appunti
	- materiale a supporto del laboratorio
	- video lezioni su yt
	- letture suggerite
	- strumenti per lezioni e laboratorio

Laboratorio è parte integrante del corso dove si spiegano cose diverse dalla lezione
Meglio studiare prima di fare laboratorio
Se prof. va veloce fare domande

Organzizzazione corso:
	58h di lezione circa
	24h esercitazione circa
	18h laboratorio fisse

Esercitazioni poste alla fine di ciascun argomento
Laboratorio si svolge qui, in aula B8.1.1 (ci sarà una volta in cui saremo in B8.0.3 che non è dotata di presa eth)
BYOD

Prove in itinere:
	1) 17 Aprile
	2) fine corso, prob. 2 luglio
	durante la seconda prova anche appello completo

Esame solo scritto
	3 esercizi simili a quelli visti a lezione/eserc
	1 esercizio di laboratorio
	domande risposta aperta/chiusa
	5/6 pt x es, 8/9pt x domande, 6pt laboratorio, totale 32punti
Punti extra per chi frequenta: alla fine di ogni capitolo (sono 5) ci sono dei test online fatti su kahoot.it in classe usando PC, smartphone o tablet
	3pt per frazione di risposte esatta su totale complessivo 3x(0.boh)
	1 punto premio per chi vince la gara di ogni capitolo
	Non è possibile rispondere da remoto

No orale se non per casi critici

Scopo: 
Introduzione alle interfacce di rete
Controllare interazione tra app e rete, configurare rete, prevedere il comportamento della rete e prestazioni, monitorare il sistema e risolvere i problemi, pronti ai cambiamenti tecnologici

Le applicazioni sono sempre più distribuite 

Oggi sviluppare un'applicazione comporta
	1) scrivere le componenti server
	2) inserirle in VM
	3) istanziarle su un servizio cloud
	4) Scrivere le componenti cloud per più piattaforme
	5) Inserirle negli store
	6) Aspettare che gli utenti scarichino le app
	7) COntrollare la relazione con la rete

Applicazioni di reti
Tendenza SDN, Software Defined Network, ovvero controllare la rete con applicazioni di rete, costituisce una grande fetta di mercato di lavoro

Comeptenze miste per ingegneria dell'informazione 

Primo corso che dà un assaggio di indirizzo comunicazione, divisi al terzo anno
Al secondo anno ci sono scelte parzialmente vincolanti

3 scelte 
	logica e algebra - insegnamento taba OPPURE elettromagnetismo e campi
	e altre, le slide sono sul web @ https://www.dropbox.com/s/74xcv629ddkfg1k/1 - Introduzione e architetture v2019.pdf 
	informazione e stima è insegnato da ingegneri, probabilità e statistica da matematici
	per info logica e algebra per info

logica e algebra + taba + algoritmi e principi per info (X INFORMATICA)
se indeciso anche informazione e stima, gruppo taba onde el. e mezzi trasmissivi, API

x com indecisi
	informazioni e stima
	el. e campi
	logica e algebra e onde el. e mezzi
	segnali per le comunicazioni

Breve storia di internet
ARPA Network (ARPANet) nel 1969 (4 nodi)
Padri: Kleinrock, Lawrence Roberts
1972: nasce NCP, primo porgramma di posta elettronica, 15 nodi di arpanet
1970: ALOHAnet rete radio a pacchetti per univ. Hawaii
Cerf and Kahn definiscono i principi dell'internetworking
1976: nasce Ethernet nei laboratori Xerox @10Mbps
1979: ARPANet 200 nodi

Anni '80: nasce SMTP, FTP, DNS. TCP/IP sostituisce NCP
Nuove reti nazionali: Csnet, BITnet, ...
Per il web bisogna aspettare gli anni 90 (Tim Berners Lee), Mosaic->Netscape
Anni 2000: problema di sicurezza (Diffie-Hellman-Merkle) velocità in Gbps
2010 - oggi: esplosione mobile internet, arrivano smartphone
CAIDA's IPv4 Map Feb 2017

99% del traffico internazionale di internet è sui cavi sottomarini
cybermap @ kaspersky

Programma del corso (prima parte):
1) Introduzione e architetture
2) Sistemi di comunicazione
3) Modelli funzionali
4) Livello fisico 

Approccio TOP-DOWN (della pila ISO/OSI)

Martedì 12 Marzo pomeriggio in Leonardo siamo invitati ad un seminario per vedere un esperimento di fotografia, digitalizzazione e invio nell'edificio 20.

seconda parte
5) protocolli applicazivi
6) trasporto (UDP/TCP)
7) livello di rete (networking)
8) inoltro in internet (inoltro, instradamento)
9) rete locale e livello di linea (Layer 2)

In laboratorio usiamo wireshark, ping, traceroute, dig, F12 di chrome, protocolli applicativi
Python escripting per analisi di rete
Programmazione socket in Python
Packet tracer
attività sperimentali su wireless

//note4selfl8r https://www.jetbrains.com/pycharm/download/#section=linux

è possibile frequentare il CORSO CCNA e fare il test CCNA. Il test costa poco (<100 €) ma la preparazione un po'di più
Ci sono 4 moduli
CCNA1, ..., CNNA4

Giochiamo con un analogia per capire il networking
Nome Cognome Indirizzo

parliamo di rotte (route), router,
prova con kahoot

NICKNAME: CODICE PERSONA + PRIME 6 LETTERE DEL COGNOME

velocità di propagazione = velocità luce 299 792 458 m/s
/**********/
Mercoledì 27 febbraio 2019
/**********/
Argomenti: Concetti base, architettura e componenti, meccanismi base e nomenclatura
Cos'è internet?
	1) È un'infrastruttura fisica fatta di componenti
	2) Un'architettura di rete
	3) Un servizio di comunicazione (comprende protocolli di comunicazione)
Componenti fisiche: 
	HOST = terminali connessi alla rete
	LINK = collegamenti = canali di comunicazione (rame, fibra, satellitare)
	ROUTER = nodo di rete
	altri nodi di rete locali (switch, access point, modem,...)
	
	HOST
		sono in grado di inviare e ricevere info su internet
		sono diversi tra loro pc, stampanti, iot devices, server
		host virtuali VM che non facciamo in questo corso
	LINK
		possono essere di natura fisica diversa(rame, radio, fibra ottica, ...), diversa tecnologia di trasmissione dell'informazione, diverse velocità di trasmissione in bps
	ROUTER
		Sono nodi di rete che operano sui pacchetti
		opera a 3zo livello pil ISO/OSI (solo router), switch 2ndo livello, alcuni anche terzo
		anche access point
ISP ->internet service provider col quale ci si connette tramite tecnologie di accesso a internet
Accesso a internet: dialup
	via modem fino a 56kbps; accesso diretto al router dell'ISP mediante circuito telefonico; trasmissione del segnale in banda fonica
	Molto ristretto perché limitato alla banda telefonica 0 - 4 kHz
Accesso tramite ADSL ( asimmetric digital subscriber line)
	fino a 1Mbps upstream, 20 Mbps downstream)
	condivisione del doppino con la rete telefonica fino alla centrale
	accesso al router del provider mediante rete dati ad alta velocità
	Il segnale non passa dalla rete telefonica (limitata dalla banda), per cui si basa sulla qualità del doppino telefonico
Accesso tramite fibra ottica
	Sostituzione totale/parziale del doppino telefonico con fibra ottica
	FTTH - Fiber to the home
	FTTB
	FTTC
	FTTN
Accesso tramite rete cellulare
	GPRS/EDGE ~200kbps
	HSPA ~14,5(D)/5,7(U) Mbps
	LTE ~300(D)/85(U) Mbps
	rete d'accesso contente core network mobile operator

Reti di reti
	Consente di fare comunicare diverse reti interconnesse cucite insieme in qualche modo
	ISP
	Eterogeneità della reti con meccanismi di interconnessione(protocollo IP)

Tipi di reti in base all'estensione geografica
	LAN: local area network
	MAN: metropolitan area network (cabine cittadine)
	WAN: wide area network
	
Architettura di interconnessione
	CN = customer network (rete casalinga, utente finale)
	POP = point of presence (altro estremo rispetto al CN, più vicino a ISP, È il punto di giunzione)
	ISP = internet
	NAP = neutral access point o MIX, IEP (internet exchange point, ce ne sono 2/3 in italia, 1 a milano caldera, 1 a Napoli). Diversi nodi di più operatori in un luogo di terzi si connettono tra di loro. Scambio di traffico dati. Possono esistere collegamenti diretti peer-to-peer tra ISP. Gerarchie tra ISP.
	BSP = Backbone Service Provider. È il fornitore di servizi internet agli ISP per collegamenti internazionali / intercontinentali.

Servizio e protocolli di comunicazione
	Servizio di comunicazione può essere il servizio postale. Esistono regole di consegna se no niente servizio. Quello che c'è nella lettera non è affare della posta.
	Il servizio di comunicazione è il rapporto cliente(alto)-fornitore(basso)-destinazione(alto).
	Servizio SOCKET: meccanismo per accedere all'interfaccia di rete (trasporto LV4) dal SO.
	Si possono trasportare messaggi di vario tipo, dalle più complesse alle più semplici
	
	Protocollo di comunicazione: stessa lingua, ordine dei messaggi
	Esempio della posta elettronica SMTP sulle slide
	Modelli:
		-client-server: uno funge da client (richiede), l'altro da server(risponde) (es. SMTP, HTTP, ...)
		-peer-to-peer: i terminali collaborano senza distinzione di ruoli (fungono sia da server che da client) (gnutella, ...)
	
Come funziona internet? DOmanda occupa l'intero corso
Come può essere trasferita l'info?
	1) Commutazione di circuito
		Rete fatta di fili cuciti insieme per arrivare a destinazione che potevano essere manuali (centralinista). Pezzi di filo con ponti fatti a mano.
		La figura del centralinista è sostituita da mezzi automatici ma la commutazione di circuito era rimasta nella telefonia fissa
		Condivisione della rete.
		Ricerca di circuito, apertura del circuito e conversazione tramite impulsi elettrici. Una volta terminata la conversazione i brani di filo vengono rilasciati.
		Necessita di fili, conduttori separati. 
		Suddivisione della banda del collegamento in frequenza o in tempo
		Collegare insieme ingresso e uscita con modello di nodo (commutatore a circuito).
[ Numero di archi in un grafo completo = n*(n-1)/2 ]
	2) Commutazione di pacchetto
		informazione suddivisa in pezzi;
		collegamenti non suddivisi;
		ciascun pezzo (pacchetto) ha una intestazione (header) che indica l'indirizzo di destinazione e altre informazioni per la comunicazione che è diverso dal contenuto.
		Non esiste un canale dedicato, il pacchetto fa dei salti tra router
		I router possiedono una tabella di instradamento che assegnano un gruppo di indirizzi di destinazione al nodo verso cui inoltrare le informazioni
		I router hanno computazione parallela e non sequenziale per gestire meglio la gestione della lista. 
		
		Il flusso di dati è suddiviso in pacchetti che occupano completamente il canale, poi da ricucire insieme
		
		Modello di nodo (packet switch/ router)
			l'arrivo dei pacchetti è asincrono; la capacità dei collegamenti è arbitraria; possono esserci conflitti temporali per la trasmissione;
			serve memorizzare contemporaneamente (coda): in ingresso per analizzare indirizzo destinazione; in uscita per gestire confitti

		Contesa per le risorse: 2 modi per gestire le cose
			store and forward: il commutatore deve ricevere l'intero pacchetto prima di inviarlo sul collegamento in uscita: non si elabora se non è completamente ricevuto
			cut-through: altra modalità di gestire le code (per questo corso dimentichiamocelo) che inizia ad inviare prima di avere ricevuto i dati ma solo l'header
	Confronto tra pacchetto e circuito
		Collegamento da 1 Mbps, n utenti. Utente genera 100 kbps quando è attivo; è attivo per il 10% del tempo.
		-> commutazione a circuito con 10 utenti: 10 utenti (1 Mbps / 100 kbps = 10)
		-> c. a pacchetto: con 35 utenti, la probabilità di avene >10 attivi è 0,004%.
		
	La storia di internet nasce con la scelta della comutazione a pacchetto.
	
	Esistono 2 tipi di comm. di pacch. 
		- datagram (IP)
			la scelta della porta è fatta basandosi sulla porta di destinazione

		- circuito virtuale (tecnologie usate dagli ISP per gestire in modo + efficiente i collegamenti internet)
			assegnazione di un label univoco (CVI) ad ogni pacchetto
			tabelle più corte perché basate su CVI ma più dispendioso per scrivere le label


1c - Ritardi e throughput: tempi di trasmissione, propagazione, altri ritardi, throughput
Velocità di trasmissione
	È la velocità (rate) R con cui l'info digitale viene trasmessa su una linea = num. bit nell'unita di tempo
	È misurata in bit/s (bps) (bit per second)
	1 B = 8 b;
	1 kbps (kb/s) = 10^3 bps; 1 kB = 10^3 B;
	1 Mbps
	1 Gbps
	durata di trasmissione di un bit è inverso della frequenza

	Il tempo T per trasmettere L bits dipende dalla velocità di trasmissione R
	L [b] , T [s], R [bps]
	T = L / R
	[s]^1 = [b]^1 / ([b]^1 * [s]^-1) = [s]^1 = [b]^1 * [b]^-1 * s[1] = [s] = [s]

	Il max della velocità nell'universo è la velocità della luce
	Il ritardo di propagazione
	Il tempo tau affinché un impulso trasmesso dal trasemttitore TX raggiunga il ricevitore RX dipende dalla distanza D in m e dalla velocità di propagazione v in m/s, prossima alla vel. della luce (= c = 3*10^8 m/s
	tau = D / v
	tau [s] = D [m] / v [m/s]
	Noi assumiamo che la velocità di trasmissione sia 2/3 della velocità della luce (200.000 km/s)
	Tempo di attraversameto del canale = T + tau
	
	T = t2-t0 = t3-t1 = L/R (si riferisce a esempio slides)
	tau = t1-t0 = D/v
	
	Esempio di store and forward supponendo che l'elaborazione nel router di mezzo sia immediata
	Tempo totale = TAB + tauAB + TBC + tauAB
	Si suppone solo che sia store and forward

Architettura di un nodo (software-switch vs hardware-switch)
	Tante NIC collegate al bus I/O. C'è system bus tra memory e CPU.
/*********/
Giovedì 28 febbraio 2019
/********/
Nella lezione precedente ritardo di un nodo
2 modelli: modello classico di un nodo simile ad un PC con CPU, mem e più NIC; nodo con architettura hardware dedicata.
Tempo attesa pacchetti in ingresso (quasi nulla per nodi con hw switch)
Capacità di processamento è limitata dal tratto in uscita del nodo. Spesso la capacità è misurata in bit/s (in realtà pacch/s moltiplicate per la lungh. media del pacchetto)
2 ragioni del ritardo tau: linea occupata o lookup della tabella. Spesso il lookup della tabella è 0, per cui noi assumiamo che sia 0, l'accodazione dei pacchetti dipende.

(slide 115) un nodo della rete continua a trasmettere a velocità più alta possibile (livello 3, a livello di trasporto le cose cambiano)
	ci sono 2 pacchetti: a e b trasmessi da A a B. Ma T2A è aumentata perché la velocità del collegamento 2 è inferiore a quella del link 1.
	Il pacchetto verde (b) non può quindi essere trasmesso subito, ma deve aspettare che il pacchetto viola arrivi.
	Quando il pacchetto viola è stato trasmesso parte la seconda trasmissione.
*	T1B non è preso in considerazione perché la trasmissione avviene in parallelo, si conta il più lungo.
(slide 116)
*	In questo caso i due pacchetti vanno in due parti diverse e vanno mandati nello stesso momento

Multiplazione statistica
	Il ritardo di accodamento dipenda della velocità del link e dal ritardo in uscita 
	La coda non serve per compensare alla velocità in uscita dal link
	Pacchetti droppati

	Ritardo di accodamento 
	L -> lunghezza dei pack
	lambda -> frequenza dei pack
(slide 120)
	Quindi se l'intensità di traffico ~0 allora ritardo in coda è piccolo, se ->1 (tende a) il ritardo tende all'infinito
(s. 121) formula del ritardo di accodamento medio
Se il ritmo di avvio si avvicina al ritmo di uscita allora ritardi e packet drop.

Perdite di pacchetti
	le code hanno dimensioni limitate. In congestione (ritmo di arrivo troppo elevato), i pacchetti vengono scartati
	i pacchetti persi possono essere ri-trasmessi oppure no a seconda del protocollo di trasporto che gestisce l'evento di perdita.
	
1d - modelli di servizio e livelli dei protocolli
(servizio di comunicazione, protocolli, primitive di servizio, architetture a livelli, funzioni di rete)
Esempio dei due interlocutori come due entità (A e B) che vogliono comunicare.
In orizzontale avviente il colloquio, in verticale il servizio.
Primitive di servizio: chiamate di servizio.
	\-> regole di accesso, descrivere il s., richiederlo, ricevere informazioni.
	\-> caratterizzate da parametri quali: info da trasferire, info destinatario, caratteristiche del servizio
	
Le primitive possono essere considerate dei punti di passaggio (service access point).
___nodo a__                    ____nodo b_____
|ente A   |                    |     ente B   |
|         |                    |              |
|   A2    |<--colloquio------->|      B2      |
|         |                    |              |
|         |                    |              |
|   A1    |<------colloquio--->|      B1      |
|         |                    |______________|
|_________|                          ^
       |_____________________________| 
              Canale bidirezionale

(slide 130)
2 modalità di servizio di comunicazione:
	Modalità senza connessione (UDP, ndr)
		- una sola fase di invio
	Modalità a connessione (TCP, ndr)
		- instaurazione della connessione
		- trasferimento della informazione
		- rilascio della connessione

Le reti sono organizzate a livelli: i colloqui devono essere mediati dai livelli inferiori
Le reti sono divise in pezzi orizzontali per semplificare le cose una alla volta
I livelli servono ad arricchire il servizio di comunicazione

Protocolli di comunicazione 
	la logica con cui creo, trasmetto e ricevo i messaggi è un protocollo. (es. grammatica per il colloquio)
	Insieme di regole per colloquiare tra lo stesso livello
	Non c'è un solo modo. problema delle scelte da prendere.

PDU = Packet Data Unit = unità di trasferimento dati. È formato da:
	header 	-> informazione di servizio necessaria al coordinamento tra le entità
	dati 	-> informazione vera e propria ricevuta dai livelli superiori

Architettura a livelli (s. 134)
	Overhead = info. aggiunta (header)

PILA ISO/OSI (questa non l'ha considerata per ora)
____________________
|Application   Lv 7|  MESSAGES - MESSAGGI
|__________________|
|Presentation  Lv 6| 
|__________________|
|Session       Lv 5|
|__________________|
|Transport     Lv 4|  SEGMENTS - SEGMENTI
|__________________|
|Network       Lv 3|  PACKETS - PACCHETTI
|__________________|
|Data link     Lv 2|  FRAMES - TRAME
|__________________|
|Physical      Lv 1|  BIT
|__________________|

Ciascun livello ha il suo compito
È più facile gestire aggiornamenti e cambiamenti se limitati a solo un livello

PILA TCP/IP

____________________
|Application   Lv 5|  MESSAGES - MESSAGGI
|__________________|
|Transport     Lv 4|  SEGMENTS - SEGMENTI
|__________________|
|Network       Lv 3|  PACKETS - PACCHETTI
|__________________|
|Data link     Lv 2|  FRAMES - TRAME
|__________________|
|Physical      Lv 1|  BIT
|__________________|

Wireshark: analisi pacchetti di rete
	\-> è uno sniffer di rete. È un modulo interamente passivo che non può inviare pacchetti autonomamente.
	formato file .pkcap
	
	Il packet analyzer consente di analizzare i contenuti e lo header dei pacchetti
	wireshark è solo una interfaccia grafica, il motore è libpcap / WinPCap.

	00:00:0c -> cisco

Funzione Multiplazione (per l'andata, demultiplazione in ricezione)
	mettere insieme e separare flussi informativi
	più livelli superiori possono condividere lo stesso servizio di comunicazione, per cui devo potere distinguere le informazioni con una "etichetta"
	Il numero di porta di TCP (lv.4) serve a questo scopo
	Una macchina può avere più applicazioni, che sono distine in base ad un numero di porta.
	La funzione di multiplazione può essere implementata a qualunque livello.
(slide 142)	
Funzione di controllo d'errore
	Garantire affidabilità nella trasmissione (CRC)
	Trasmetto un pacchetto e alla fine aggiungo il trailer (coda) composta dal codice di controllo
	Acknowldedgment e timeout
	
Funzione di instradamento (routing)
	\->trovare la strada verso un'altra rete
	Esiste una entità e più uscite. Da dove arriva il pacchetto? Dai livelli superiori (es. lv n)
	L'indirizzo va messo prima che venga inviato all'entità instradante.
	L'indirizzo del livello n  viene scritto e si decide dove inviarlo a seconda della tabella di instradamento.
	
	Il pacchetto può arrivare da una porta di ingresso.
	L'entità instradante fa il forwarding (consulta la tabella e viene inoltrato verso l'interfaccia corrispondente in tabella).
	
	esempio slide 145
	nei nodi di rete i livelli considerati dagli apparati router si fermano al livello 3. Gli switch idem ma con il livello 2.
	Proxy: funzione di rete a livello applicativo.
	Chi scrive le tabelle di instradamento?
		\-> "Human defined Networking": rotte statiche scritte a mano.
		\-> MAC learning fatto dalle macchine di rete
		\-> "Software defined networking" SDN
/*********/
Mercoledì 6 marzo 2019 (sì, ho perso una lezione)
/*********/
reminder demo/seminario livello fisico martedì 2019-03-12 h.16:00 EL.0 (Leonardo) max.2 ore
1b. livello fisico
aspettiamoci il primo kahoot
Segnali e frequenze
Siccome non abbiamo visto le trasformate in analisi 2, abbiamo meno strumenti per comprendere questa cosa
I segnali: sorgenti di informazioni che possono essere
	digitali, numerici

	segnali fisici: sorgenti continue
	(es. radio FM vs DAB: digital audio broadcasting)
	a noi interessano i segnali digitali. Conversione da analogico a digitale attraverso campionamento e quantizzazione. In output avremo dei bit
	
	segnali nel dominio del tempo? Meglio di no, è più comodo vedere i segnali nel dominio delle frequenze.
	Con la trasfomata di Fourier.
	Tempo misurato in secondi, frequenza in Hz (secondo alla meno 1) [T]^-1
	I segnali sono scomposti in molte sinusoidi, che sono le frequenze che lo compongono.
	Lo spazio in cui la f ha valori =/= 0 si chiama banda del segnale
	L'analisi di Fourier è comoda per segnali periodici, come le sinusoidi. 
	Insieme continuo vs discreto.
	L'onda quadra è formata da una serie di Fourier di sinusoidi (se è periodico, se è discreto la trasformata).
	s(t) nel dominio del tempo e S(t) (che è lo spettro del segnale) è nel dom della frequenza.
	Se continuo a sommare sinusoidi con tutte le sue armoniche ottengo un onda quadra nel dom. del tempo.
	La banda di un onda quadra è infinita ( perché la pendenza è verticale), ma noi prendiamo una banda limitata.
	Più le transizioni sono nette, maggiore sarà la banda
	media nulla = non c'è la componente continua (f=0), altrimenti c'è ed è costante
	la media non è nulla perché il grafico era spostato verso l'alto e non era alternato
	Esempio onda a dente di sega.
	I segnali non periodici non hanno uno spettro discreto ma continuo
	SYNC ha banda infinita e spettro è sin(x)/x . Bisogna tagliare le frequenze esterne del sync per poterlo spedire. Cambierà un pochino la forma del segnale
	Banda stretta (segnale che varia lentamente) e banda larga: varia velocemente nel tempo.
	Più la banda è larga più energia in TX ci vuole.
	

	Segnale telefonico ha banda (300 - 4000 Hz) Fc:	8KHz	lv.	256	8 bit			 Flusso binario	64  kb/s
			voce 				(300 - 8000 Hz)		16KHz			16 bit							256 kb/s	
			musica 				(100 - 8000 Hz)		40KHz			16 bit							704 kb/s
			TV(PAL) (analogica) (0 - 5 MHz)			10MHz			24 bit (colori)					240 Mb/s
			cinema 				(0-500 MHz)			1GHz			24 bit (colori)					24  Gb/s
	
Conversione analogico-digitale
	Rappresentazione umana: modo analogico
	Elaboratori numerici: discreto
	
	Diversi passaggi
	1) CAMPIONAMENTO
		Definisco un periodo (frequenza) di campionamento
		
		Teorema di Nyquist(-Shannon questo lo dico io)
			fc >= 2B = fN (frequenza di Nyquist)
			(la frequenza di cmapionamento deve essere 2 volta la banda per poter essere ricostruita)
		
		Se non rispettiamo il teorema di Nyquist, il segnale ricostruito è sbagliato, alterato. Evitare questo
		Se la banda è larga bisogna aumentare la frequenza di campionamento, altrimenti no
		
		Con un filtro rimuovo le frequenze non deisderate (somiglia ad un mezzo trasmissivo)
		Sempre con un filtro passa basso (da 0 a 2B)riottengo il segnale originale 
	
	2) QUANTIZZAZIONE
		È l'operazione che trasforma un segnale da continuo a discreto.
		Quindi sull'asse delle ordinate non ci saranno più tutti i numeri ma solo un certo numero di "gradini"
		Nella trasformazione si commette un errore di approssimazione (quantizzazione)
		Più livelli ci sono meno errori di quantizzazione. Ogni livello è rappresentato da una sequenza di bit
		Ricondurre poi ciascun campione ad un livello

		l = 2^b
		l = num.livelli di quantizzazione
		b = num.bit per livello

Modulazione e trasmissione
	La trasmissione di un segnale digitale (numerico) richiede di creare un opportuno segnale adatto per essere trasportato sul mezzo fisico.
	La sequenza digitale viene usata per modificare (modulare) un qualche parametro del segnale (modulato) inviato nel mezzo trasmissivo.
	Modulazione in banda base (spettro contiguo rispetto all'origine)
	Banda traslata (non vicine allo 0)
	Modulazione in banda base basata sugli impulsi.
	PAM - Pulse Amplitude Modulation
		\-> il bit corrisponde ad un impulso di ampiezza positiva (1) o negativa (0)
	
	Modulazione in banda traslata:
		si crea un onda EM (sinusoide) detta PORTANTE (carrier) ad una determinata frequenza (fp) per traslare lo spettro del segnale intorno alla frequenza della portante
		
	R = 2B
	In caso di modulazioni in banda traslata efficienza spettrale = 1 bit per Hz
	Onde elettromagnetiche

	Modulazione in banda traslata
	\->	ASK Amplitude Shift keying	: modulazione in ampiezza della carrier
		FSK Frquency				: modulazione in frequenza carrier
		PSK Phase					: moudulazione in fase carrier
		QAM	(quadratura)			: cambiamento misto di ampiezza e fase
	
	Modulazione multilivello
		impulsi su più livelli (es. 8-PSK, 16QAM) (sul cellulare fino a 256 livelli)
	
	Aumenta l'efficienza spettrale. SImboli al secondo = baud (vecchio nome)
	Esiste un valore massimo di robeh calcolata da Shannon
	
	Mezzo trasmissivo: riceve il segnale in ingresso e lo trasporta, ma viene alterato (es. ritardo, minor potenza).
	Attenuazione	della potenza in funzione dela distanza percorsa e della frequenza del segnale;
	Dispersione		ritardo differente per ogni componente in frequenza
	Banda passante del canale (mezzo trasmissivo) è la regione in cui si ha la migliore risposta in termini di attenuazione e dispersione.
	
	Mezzi trasmissivi guidati(wired) o non guidati (wireless)

	Attenuazione = Pout/Pin in dB. A(dB) = 10logb10(Pout/Pin)
	A = kd^-x	x=2,3,4,5
	
	Errori in ricezione.
	Cause:	- rumore termico (mezzi trasmissivi, apparati di tx e rx)
			- interferenza
			- other
	Il rimore è un processo casuale 

	Codici correttori
		Si può abbassare la probabilità di erore in un blocco con codicei correttori d'errore (Forward Error Correction FEC) = bit di ridondanza/parità
	Ritrasmissione: se ci sono errori, ritrasmetto il pacchetto errato (ARQ - Authomatic Repeat reQuest)
	
	Capacità di canale dimostrata da Claude Shannon nel 1940.
		C = B*logb2(1+S/N)

		C 0 capacità del canale [bps
		B = banda del canale [Hz]
		S = potenza del segnale [W]
		N = potenza del rumore [W]
/**********/
Giovedì 7 marzo 2019
	
Speigone sulla lezione di ieri (modulazione e trasmissione).
Banda base (origine) e banda passante (lontana).
Modulazione in banda traslata è un casino
Efficienza spettrale media

A  sin(2*pi*f *t+fi )
 k           p     k

Ak = ampiezza; fp = frequenza; fik = fase
Modulazione multilivello

s(t)  _______   r(t)                   r(t) = b * s(t+tau)  	b è la costante di attenuazione
----->| H(f) |------->              
S(f)  |______|  R(f) = s(t) * H(f)     R(f) = g * S(f)

Attenuazione è rapporto tra potenze
Codici correttori
	Bit di parità: sono due bit messi in fondo alla stringa che fanno in modo che i bit in posizione dispari e pari rispettivamente siano entrambi pari
	Es.  __________________
        | 00111111100010|11|
Cont.   |_______________|__|
Dispari   0 1 2 3 4 4 5  6
Pari       0 1 2 3 3 3 3  4

IL LIVELLO APPLICATIVO

Processi e socket, peer-to-peer, web, mail, DNS

Studiamo i seguenti protocolli applicativi
HTTP, SMTP, BitTorrent, Video streaming

Creare un'applicazione di rete è scrivere un software che possa essere eseguito su diversi terminali e possa comunicare tramite la rete
Obiettivo del laboratorio con applicazioni di rete è fare una cosa semplice che funzioni in rete

I nodi della rete non hanno software applicativo, le applicazioni sono installate solo sui terminali
Comunicazione tra processi. Attori: host, processo e IPC (comunicazione tra processi).
/**********/
Lunedì 11 marzo 2019

Cosa contiene pagina HTTP?
Locator: URL
La pagina è fatta di oggetti (file HTML, applet java, video,...)
URL composto da protocollo applicativo, indirizzo del server, porta e pagina richiesta

HTTP è client-server con protocollo stateless (nessuna memoria sulle richieste è mantenuta sul server con il protocollo HTTP).
La comunicazione è fatta con richieste e risposte (protocollo asimmetrico)
HTTP si poggia su TCP e utilizza la porta server n.80 di default.

2 modalità: non persistente e persistente
	non p.: c'è una connessione per ogni oggetto, chiusa ogni volta che il trasferimento è terminato. (parallelo)
	pers. : la connessione viene lasciata aperta e invia in serie le richieste una dietro l'altra

Tempo impiegato per trasferimento in andata e ritorno: RTT, piccolo pacchetto
Tempo totale è una sommatoria di RTT + tempo di trasferimento del file
Le richieste HTTP
	sono codificati in ASCII (utile perché leggibile, ma più dispendiosa in termini di bit occupati dal messaggio).
	Nello header c'è il tipo di messaggio, host, user-agent, linguaggi accettati e se è persistente oppure no.
	HTTP 1.1 è keep-alive (persistente) di default, la versione 1 era non persistente di default
I metdodi HTTP:
	GET		chiede pagina
	HEAD 	chiede informazioni sul documento
	POST	fornire input al server utilizzabile da un oggetto
	PUT		memorizzare un documento nel server
	DELETE	elimina documento
Esempi di header:
	cache-control:		info sulla cache
	accept:				formati accettati
	accept-language:	linguaggi accettati
Le risposte HTTP
	contiene lo status code, identificati da un codice di 3 caratteri.
	1xx	info
	2xx success
	3xx redirect
	4xx client error
	5xx server error
messaggi accompagnati da scritta in inglese
Esempio pratico col telnet

Contitional GET
	Serve per non scaricare gli oggetti se non sono stati modificati dalla data dell'ultimo trasferimento
	L'header da inserire è if-modified-since: <date>
	Se l'oggetto non è modificato, viene resttuito il messaggio 304. Il browser visualizzerà la copia locale anziché quella sul server

youtu.be/astJTu59BfY 	richiedere pagine con http1.1
youtu.be/YfIILUI5S0E 	inviare get condizionato

strumenti per l'analisi del traffico HTTP all'interno del browser web
	Chrome dev tools
trasferimento files con curl curl -o /dev/null -s -w "%{time_total}\n" www.antlab.polimi.it
trasferimento file con telnet

Esempio telnet:

lorenzo@lorenzo-VirtualBox:~$ telnet antlab.elet.polimi.it 80
Trying 131.175.187.69...
Connected to antlab.elet.polimi.it.
Escape character is '^]'.
GET /images/antlab_small.jpg HTTP/1.0

HTTP/1.1 302 Found
Date: Mon, 11 Mar 2019 12:14:34 GMT
Server: Apache
Location: https:///images/antlab_small.jpg
Content-Length: 216
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href="https:///images/antlab_small.jpg">here</a>.</p>
</body></html>
Connection closed by foreign host.

fine esempio. 

Mantenere lo stato in HTTP: i cookies
	Strumento utilizzato dal server per memorizzare qualcosa sul client
Memoria condivisa: il PROXY
	Le richieste inviate a qualunque server sono deviate verso una macchina chiamata PROXY, che risponderà a tutte le richieste che farò.
	Il proxy chiederà al destinatario originario la risorsa e la inoltra al client.
	È un intermediario. In aggiunta a ciò se l'oggetto è disponibile nella cache del proxy server esso risponde con l'oggetto.
	I proxy sono APPLICATION GATEWAY

Curiosità: differenze tra HTTP versione 2 e versione 1.1.
	v2 è in binario e non in ascii, multiplazione, compressione header, servizio di server push (scarica anche elementi collegati).
	DEMO: https://http2.akamai.com/demo
	indexing e codifica differenziale

Sicurezza in HTTP con il protocollo sicuro HTTPS
	confidenzialità: solo chi può ricevere riceve
	integrità: nessuno modifica i dati
	autenticazione: chi invia è veramente chi dice di essere

	Connessioni SSL/TLS: 1) handshake con autenticazione da ambo i lati. Poi vengono scambiate le chiavi di cifratura. 2)Trasferimento dati. 3) Chiusura connessione
	Crittografia simmetrica ed asimmetrica (root certificate = certificati truffaldini)

/**********/
Giovedì 13 marzo 2019

Il servizio di posta elettronica
SMTP RFC 5321
POP3 RFC 1939
IMAP RFC 3501

Il servizio consiste in un client aka user-agent, di un mail server, di un protocollo di invio (SMTP) e dei protocolli di accesso per scaricare la posta (POP3, IMAP)
Ciascun server gestisce un dominio e gli utenti validi devono avere una casella che corrisponde ad un indirizzo valido (il dominio è quello dopo @)
Il server di posta in uscita funge da proxy (riceve e poi invia, inoltra, fa da intermediario). 
Questo è come funzionava, oggi c'è un livello di sicurezza in più col server in uscita che chiede l'autenticazione dell'utente.

SMTP
	Protocollo client-server che usa TCP con porta nota lato server 25.
	Mette il messaggio in coda, apre connessione con il mail server del destinatario, trasferisce il messaggio e chiude la connessione TCP.
	Comandi e risposte testuali in ASCII, come pure i messaggi.
	
	Esempio di trasferimento.
	Colloquio tra client e server SMTP.
	Messaggio composto da Header (to, from, cc, subject) e dal body.
	I messaggi finiscono tutti con una punto soltanto su una linea

	Multipurpose Internet Mail Extensions MIME (RFC 2045-2046)
	Estende il formato dei messaggi email per trasferire dei contenuti diversi dal testo ASCII. (es. immagini, video, HTML)
	Bisogna aggingere degli header
	MIME-Version: 1.0
	Content-Transfer-Encoding: base64
	Content-type: image/jpeg
	
	Potrebbero anche esserci più parti in un testo (allegati).
	Esempio di invio email
Protocolli di accesso al mailbox attraverso 2 protocolli: IMAP o POP3. Può anche essere fatta attraverso HTTP per la webmail
POP3. Più semplice e con meno funzionalità
	- Connessione al server (TCP port #110)
	Questi sono i comandi utilizzabili
	- user: user lorenzo
	- password: password prova123ssassa
	Risposte del server: +OK oppure -ERR
	Fase di transazione in cui il client fa
		list
		retr	
		dele
		quit
IMAP: vantaggio delle directory
	
VIDEO: youtu.be/v4Zpywa8ag0
Scopo: inviare una email da un mittente falso al proprio indirizzo di posta elettronica

Conversione tra nomi simbolici e indirizzi:
DNS - Domain Name System
Converte da nome a numero (è un servizio di pagine gialle distribuito)

È composto da database distribuito costituito da molti name servers con organizzazione gerarchica. Il servizio è basato su UDP.
Servizi aggiuntivi: host aliasing (sinonimi), mail server aliasing, load distribution

I server sono organizzati con la stessa gerarchia dei domini
	.com		.it			.org		TLD (Top level Domain)
bing		polimi		wikipedia		nome a dominio
										

La parte di organizzazione semplice, organizzazione un po' più complessa.
13 root name servers (NS).
Local name server è quello che fa da interfaccia tra utente e mondo dei server DNS.

Server authoritative è responsabile di quel particolare hostname
Se il server ce l'ha in cache e fornisce risposta senza contattare il server la risposta è non-authoritative
Ogni host ha un LNS (local name server) che fornisce alle applicazioni i nomi a dominio e li tiene in cache

Esempio di risoluzione di un nome simbolico in modalità iterativa
Resource Record: 	NAME - VALUE - TYPE - TTL
Caching con il tempo di vita dell'informazione (TTL) per pulire memorie da info obsolete.
Type: esplicita utilizzo del DNS
	A -> 	Name è il dominio di un host e value è l'indirizzo IP
	NS ->	Name è domain e value è il nome di un server che può ottenere le informazioni relative al name
	CNAME -> name è un alias per un host il cui nome canonico è in value
	MX ->	name è un mail domain o alias, value 

Come aggiungere un dominio nella rete DNS? Con i DNS registrars
Esperimenti con dig
Meccanismi di load balancing per DNS
CDN (content distribution network [io lo ricordavo come content delivery network])
	Nasce come soluzione al problema di gestire in maniera efficiente tanti contenuti verso tanti utenti molto lontani gli uni dagli altri
	La mappatura è fatta attraverso un server DNS

Applicazioni peer-to-peer
	Il primo più famoso era napster
	Protocollo distribuito ma registro centralizzato
	gnutella non ha nessun server centrale, protocollo di pubblico dominio, client diversi
	bittorrent: i tracker tengono traccia dei peer che partecipano ad un torrent. i file sono divisi in chunk
		meccanismo di richiesta dei chuck partendo dai più rari
/**********/
Lunedì 18 marzo 2019 - 1mo laboratorio

Daniele Moro è il responsabile laboratorio
6 lezioni 3 prima la prova in itinere, 3 dopo
le prime 3 python, le altre 3 con Cisco IOS CLI 

2 modalità 
	-> creare file di testo ed eseguirlo con il comando python script.py
	-> usare la shell interattiva chiamando python

questa lezione la trovi a lab/20190318.py

/**********/
Giovedì 21 marzo 2019
Il livello di trasporto - Cap.3
UDP, TCP, controllo di flusso, controllo di congestione
Su questa parte ci sono 2 laboratori (programmazione socket
Il servizio di trasporto instaura collegamento tra le applicazioni su host remoti
Rendono trasparente il trasporto dei messaggi alle applicazioni
È presente solo nei terminali della rete
Cosa fa? Multiplazione e demultiplexing
	Più applicazioni che condividono uno stesso indirizzo IP possiedono diverse porte (lungh. fissa 16 bit)
	Divisi in 3 parti: 
		Well-known ports (0-1023): spesso lato server
		Porte registrate (1024-49151): assegnate a specifiche applicazioni poco diffuse rispetto alle well-known
		Numeri dinamici  (49152-65535): usate per la multiplazione nei client
	Connessioni in parallelo sfruttano multiplazione per aprire più connessioni
Servizio di buffering
	Il sistema operativo crea due buffer (in entrata e in uscita) per ciascuna porta creata
	Vale sia per i client che per server
Servizio di rete non è affidabile (best effort). Il servizio di trasporto fornito può essere di vari tipi
	- trasporto affidabile (messaggi consegnati in ordine corretto)
	- trasporto non affidabile
	- trasporto orientato alla connessione
	- trasporto senza conn.
Nella suite IP sono definiti 2 protocolli: UDP e TCP
UDP trasmette e basta senza controlli; TCP regola la velocità di trasferimento in base alla ricezione e della rete
UDP (User Datagram Protocol)
	È il più semplice tra i due. Aggiunge ad IP solo mux/demux (indirizzamento porte) e CRC.
	Header corto (8 byte) con poche informazioni
	Minor latenza, più semplice e leggero.
	Il checksum (controllo di errore) (in UDP è a 16 bit) viene calcolato considerando l'header UDP, uno pseudo-header IP ed i dati.
		Funziona così: le informazioni vengono divise in blocchi di 16 bit. Il campo checksum è lasciato a 0. Poi si fa la somma binaria di tutti i blocchi in complemento a uno.
		In ricezione si complementa il risultato della checksum e deve venire zero.
	Prova cattura wireshark
Trasporto affidabile
	Il collegamento ideale è ricevere la stessa sequenza di trasmissione nello stesso ordine correttamente
	Protocolli di ritrasmissione (canale di feedback, la comunicazione deve esser bidirezionale)
		Obiettivo: integrità del messaggio/pacchetto, ordine sequenza, no duplicazione
		Ciascuna trama ricevuta va riscontratapositivamento con un messaggio di ACK
		A volte l'errore può essere segnalato con un NACK
		La mancanza di ACK o la presenza di NACK segnala la necessità di ritrasmettere
		La procedura di ripete finché la trama viene ricevuta correttamente
		Controllo di integrità e recupero d'errore vengono usati da TCP.
			I pacchetti possono andare persi a livello di rete (pacchetti scartati in coda)
		Meccanismi usati: timeout e finestra di trasmissione
	Il protocollo "stop and wait"
		utilizza solo l'ACK e un contatore di timeout.
		Funzionamento corretto solo se timeout>=2*tau+Tack
		Serve la numerazione dei pacchetti (SN, #sequence) e degli ack (RN, #request). COsì facendo si evitano i duplicati e ack verso pacchetti corretti.
		Efficienza del protocollo
								     T               1
		     	 EFFICIENZA  = -----------  = ---------------
							   T+Tack+2tau    1+Tack/T+2tau/T

		efficienza è bassa se T<<tau, quindi non adatto a situazioni con alto ritardo di propagazione e/o elevato ritmo di tx.
		Protocollo utilizzato perché funziona bene su half-duplex. Bene su distanze brevi
	Il protocollo Go-Back-N
		Variante dello stop and wait.
		Si inviano un numero max di pacchetti N (finestra). Se non ho ricevuto un pacchetto, si ritrasmettono tutti quelli non ricevuti a partire dal primo perso (max N pacchetti)
		La finestra è sempre di N pacchetti ma è una sliding window e si muove a ritmo degli ack ricevuti.
		Se non ci sono errori la trasmissione non si ferma mai (100% efficienza).
		I pacchetti fuori sequenza vengono scartati. [Oggi esiste anche la variante che accetta pacchetti fuori sequenza]
		Link applet che simula la connessione a pagina 34 delle slides.
		Il riscontro (ACK) può essere collettivo, cioé non individuali che riguardano un solo pacchetto ma relativo a tutti i pacchetti precedenti.
		Dimensionamento della finestra
			La finestra ottimale coincide con il RTT (round trip time) (=T+tau+Tack+tau)
					             T+Tack+2tau
			numero minimo di N = -----------
								   	  T
			(Sincronismo degli ack dice il ritmo con cui vengono ricevuti, in caso normale =T. Sono un indicazione del tempo di trasmissione che stima la capacità del collo di bottiglia della rete)
			La finestra può essere dimensionata in byte, bit, secondi, ...
			Si complica il dimensionamento se non si conoscono i tempi di propagazione (tau), per esempio quando i tempi di attraversamento sono variabili oppure i pacchetti sono di lunghezza variabile
			Rimedi:
				fare la finestra grande. Svantaggio: in caso dierrore aumenta il ritardo e ritrasmissioni inutili.
	Uso del NACK
		Può abbreviare i tempi di ritrasmissione.
		Ma se tra le informazioni corrotte c'è l'indirizzo sorgente? Il NACK va ad un indirizzo a caso.
		Se arriva un pacchetto fuori sequenza (es. arrivano l'1 e il 3) invio subito il NACK 2. Tale cosa consente una ritrasmissione veloce
		ACK ripetuto ha la stessa valenza di un NACK. TCP usa l'ACK ripetuto.
	Go-back-N FULL DUPLEX
		Il meccanismo di finestra mobile può essere fatto da entrambi i lati. Quindi entrambi gli host trasmettono dati e ack in senso opposto.
		Quindi nell'header del pacchetto esiste il numero di sequenza ma anche il numero di ack in direzione opposta
		Generazione del numero di sequenza e mantenere una variabile con il n SEQ successivo e un'altra var con dentro l'ACK da convalidare
		Si mantengono aggiornate queste 2 variabili e usate ogni volta che arriva un pacchetto nuovo
/**********/
Lunedì 25 marzo 2019
Il secondo laboratorio è lunedì prossimo
	Go-back-N e piggy backing (slide 40)
		i sequence n e gli ack (rn) sono inseriti nello header del pacchetto
		RN assume il significato di prossimo pacchetto atteso
	Regole go back n trasmettitore:
		N -> dim.finestra
		Nlast -> ultimo riscontro ricevuto
		Nc -> numero corrente disponibile per pacchetto in trasmissione
		regole:
			ogni nuovo pacchetto da trasmettere ha un numero di sequenza. Se è >=Nlast+N, viene messo in attesa, Altrimenti viene assegnato Nc, Nc viene incrementata di 1, il pacchetto si invia e per ogni riscontro si aggiorna Nlast = Nc
		In caso di scadenza del timer, la ritrasmissione riparte da Nlast
	Logica ricevitore:
		Se ricevo un pacchetto SN=RN, inoltro ai livelli superiri e RN=Rn+1
		Ogni tanto manda al TX RN
	Schema Go-back-N full duplex senza errori

	Necessità di inizializzare i numeri SN e RN e un numero di tempo da quando si inizia a contare e scambiarsi info.
	L'inizializzazione della variabile si fa ad un numero casuale per evitare qui pro quo.

Controllo di flusso a finestra mobile
	Buffer d ricezione limitato a W posizioni (numero posti liberi nel buffer) lato ricevitore
	Ritmo di assorbimento dell'utente arbitrario
	Obiettivo: regolare il ritmo di invio per evitare che pacchetti vadano persi perché trovano il buffer pieno
	
	Sliding window flow control
		Se unito al go-back-n fa in modo che i pacchetti vengono inviati in base alla disponibilità del ricevente sia in velocità che nel buffer regolando la finestra di trasmissione
		Esempio di uso del campo W
		a volte il ricevitore mente per avere delle reazioni diverse dal trasmettitore
	
Adesso guardiamo qualche esercizio del protocollo di ritrasmissione
/**********/
Mercoledì 27 marzo 2019

Protocollo TCP (RFC 793 (1981), RFC 1122(1989) e successive implementazioni)
Assicura il trasporto affidabile (sequenza corretta e senza errori e perdite di dati)
È possibile costruire applicazioni con trasferimenti senza errori e ha semplificato il modo di progettare le applicazioni.
Meccanismi di controllo di velocità e di congestione
È alla base della net neutrality (tutti i flussi sono trattati equamente, soprattutto nella condivisione dello stesso link)
Prima la rete era controllata dall'interno
Il TCP è connection oriented, cioè ha una fase preliminare allo scambio dei pacchetti (3-way-handshake)
Le connessioni TCP si appoggiano su una rete connectionless. Conn.TCP sono full-duplex (scambio di dati da ambo le parti) che può essere definito peer-to-peer perché il formato dei pacchetti è lo stesso in ambo i versi
(half-duplex = la connessione è bidirezionale ma se trasmette uno l'altro deve stare ad ascoltare e poi trasmettere, tipo walkie-talkie)
Il TCP accetta uno stream di byte, inseriti in un buffer. TCP poi riempie i segmenti in uscita. I segmenti hanno dimensioni variabili (con una lunghezza massima concordata).

Per la numerazione dei byte e riscontri i meccanismi di ritrasmissione somigliano al goback-N
	Ogni byte è numerato e ha un numero di seq.;
	segmenti formati da gruppi di byte
	dimensioni delle finestre in byte
	Nell'header del segmento TCP è trasportato il numero di sequenza del primo byte del segmento e il primo+1 delle ack
Campi dell'header
	Source e destination port (16 bit ciascuna);
	Sequence number e acknowledgment number (32 bit ciascuno);
	16 bit di flag (1° è HLEN, lungh.header diviso 32 (lungh.min. = 20B; l.max = 40B)), 16 bit di window per il controllo di flusso;
	checksum (16 bit) e urgent pointer (16b)
	Options e padding (max 20 byte) servono per opzioni e padding per raggiungere una dimensione divisibile per 32 bit
	---fine header---
	Campo dati di circa 1460-1480 byte per farlo entrare su frame ethernet

	I FLAG (1 bit ciascuno)
	Il flag urgent dice a tcp di separare i dati urgenti dal resto che permettono di avere un flusso di controllo parallelamente ad un flusso dati (utilizzo poco frequente)
	Il flag ACK vale 1 se il campo ack numer è valido, 0 se non è valido. normalmente lo è ma all'inizio (3W-Handshake)non è così
	PUSH (PSH) forza l'invio delle informazioni il prima possibile (risultato pacchetti piccoli)
	RST reset è per terminazione brusca della connessione, non è una bella cosa perché può creare problemi di inconistenza di stato nelle applicazioni. Putroppo è usato e il programmatore deve prevedere un timeout nel caso in cui la connessione resti appesa
	SYN. Se=1, il #Seq è il primo della connessione. Con questo si fanno gli attacchi DDoS inviando pacchetti con SYN in massa
	FIN serve per chiudere la connessione in modo soft
Opzioni
	No-operation e end of option servono come padding
	MSS Maximum Segment Size
		Val.min di default è 536B, MAX 65535B. Definisce la dim.max del segmento usata nella connessione TCP. Decisa dal mittente durante dla fase di setup.
	Window scale - Fattore di scala della finestra
		Default 1 ->misuriamo in byte, altrimenti prendo gruppi di byte pari a 2^fattore di scala.
		Questo consente di esprimere con 16 bit dei numeri più grandi
	...
	http://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml
Servizi per porte note
Setup delle connessioni
	Prima del call setup le applicazioni sia client che server devono comunicare con il software TCP
	1) I server sono sempre in ascolto, i client si attivano quando vogliono.
	Demone in ascolto sulla porta è il PASSIVE OPEN (server) e aspetta che qualcuno si connetta sulla porta.
	2) Il client invece effettua un ACTIVE OPEN, effettuando una connessione
	3) il client TCP manda un messaggio con SYN=1 e scrive nel #seq un num. casuale. Eventualmente indica anche MSS e window scale
	4) Il server risponde con un messaggio con flag SYN=1 e ACK=1. Invia a sua volta un #seq. casuale e fa l'ack della richiesta del SYN del client.
	5) Pacchetto di ACK=1 inviato dal client verso il server. È il primo, un ACK puro, si inviano anche MSS e Window scaling. Dopo questo pacchetto la connessione si considera aperta
	Quasi sempre nel pacchetto di ack puro vengono inseriti i primi dati trasmessi dall'applicazione

	Lato server una volta che la connessione viene aperta, deve essere gestita (a volte forking)
	Lato client niente di che

	Chiusura connessione è in modo asimmetrico (prima da un lato, poi dall'altro)
	Tear down
	Client invia FIN=1; server risponde con una ACK=1 e invia tutti i pacchetti mancanti; server invia FIN=1; client risponde con un'ACK. Connessione chiusa.
	Cattura wireshark TCP
	C'è anche il timestamp 1322764305
	
	Implementazione del controllo di flusso.
	Lato ricevitore.
		Receiver window (RCVWND): spazio del buffer in ricezione disponibile per ricevere nuovi dati (mantenuto dal TCP in una variabile)
		Si estende dall'ultimo byte inoltrato dall'applicazione fino alla fine del buffer
		Il buffer di ricezione può riempirsi acnhe per congestione nel SO del ricevitore
		La dimensione di RCWND è segnalata in ogni segmento inviato dal ricevitore al trasmettitore.
		Quando il buffer si svuota, la finestra si sposta in avanti
	Lato trasmettitore
		Send window SNDWND è una parte inutilizzata del buffer che rappresenta i byte che possono essere trasmessi senza attendere ulteriori riscontri
		Il trasmettitore tiene un buffer di trasmissione che tiene traccia dei dati trasmessi ma non ancora riscontrati e della dim della fin del ricevitore.
		Il bffer di trasmissione parte dal pirimo byte nn ricontrato all'estremo della finestra del ricevitore
	
	Problema della finestra 
		Silly window syndrome - lato ricevitore
			il ricevitore è lento e legge pochi byte alla volta. Quindi chi trasmette invia pacchetti piccoli. Problema: a volte lo header occupa troppo spazio rispetto ai dati
			Soluzione è l'algoritmo di Clark: il ricevitore mente al trasmettitore e indica una finestra nulla finché il buffer del ricevitore non si è svuotato per metà o per una porzione almeno pari al MSS
		Silly window syndrome - lato trasmettitore
			L'applicazione genera byte molto lentamente e segmenti molto piccoli man mano che vengono prodotti

		Soluzione: algoritmo di Nagle: i primi pacchetti piccoli, quelli dopo grossi sufficientemente per riempire un MSS oppure invia subito quando riceve un'ACK
	
	Funzione PUSH
		
	Dati URGENT
		->FTP utilizza una serie di comandi inviati (CONTROLLO) parallelamente all'invio e alla ricezione dei file (DATI) sfruttando urgent
	Controllo di errore in TCP 
		È simile a quello del Go-back-N con timeout.
		Differenze: TCP mantiene i pacchetti ricevuti fuori sequenza
	Gestione del timeout
		Questo dipende dal RTT: se il server è vicino è diverso se il server sta distante
		Problemi: se RTT lungo e timeout troppo piccolo, ritrasmissione troppo frequente, bisogna avere pazienza. Timeout troppo lungo impedisce recupero veloce.
		TCP misura il RTT dinamicamente.
		Stima del RTT attraverso gli algoritmi di Karn e Jacobson. (empirico)
			Stima del valor medio sulla base delle misure. Usiamo quello smoothed di RTT:
				(i)
			SRTT    = (1-alfa)*SRTT + alfa* e altre cose che non o fatto in tempo a  copiare

			Caloclo della deviazione (DEV) = |RTT^i-SRTT^(i-1)| e calcolo della deviazione smoothed

			TIMEOUT = SRTT + 4*DEV
			All'inizio il timout è 1 secondo.
			Dopo una ritrasmissione sarebbe meglio passare all'algoritmo di Karn.
			RTT non viene aggiornato, iltimeout è moltiplicato per un valore fisso (2), il timeout cresce fino ad un max., dopo un numero max di ritrasmissioni la conn. è chiusa
			Timer di PERSISTENZA: ??? da recuperare le slide
				se il destinat
				per evitare questa situazione si usa un timer di p. che viene attivato quando arriva un segmento con finestra nulla
				se il timer di p. scade viene inviato un piccolo pacchetto sonda

/**********/			
Giovedì 28 marzo 2019
Controllo di congestione, delegato al TCP
	obiettivo: regolare il traffico senza il vigile, ognuno si regola da solo (controllo end-to-end).
	(ECN - Explicit Congestion Notification, ultima trovata per il controllo di congestione)
	aggiungiamo delle variabili: la congestion window (CWND). Ogni istante vengono confrontate la CWND e la RCVWND, quella minore trale due è utilizzata.
	CWND si basa sulla velocità sulla banda di rete. (è più difficicle saperlo perché la rete non collabora)
	La ricerca della velocità ideale si basa sui tentativi effettuati. Si aumenta la velocità finché la velocità è troppo alta.
	A quel punto scadrà un timeout e ci sarà un evento di congestione = perdita dei pacchetti)
	Meccanismo basato su 2 meccanismi: slow start e congestion avoidance
	Per decidere quale dei due utilizzare si usa la variabile slow start treshold (SSTRESH).

	Slow start:
		Si parte lentamente con l'invio di 1 segmento di dimensione massima (1).
		Ogni volta che arriva un ACK, questo valore viene incrementato di 1. (crescita esponenziale)
		Parte un pacchetto e torna un ACK. Trasmetto 2 pacchetti e arrivano 2 ack. Ciascuno di questi 2 ack genera 2 pacchetti a sua volta (tot. 4). Poi 8, 16, 32, ...
		
		L'incremento può andare avanti finché: evento di congestione, CWND<SSHTRESH, CWND<RCWND
		Insieme alla finestra aumenta anche il ritmo di trasmissione stimato così:
		R = CWND/RTT in bps
	
	Limitazioni: collegamento in uscita dal dispositivo oppure in uscita dal router
	Un link è congestionato anche quando la somma dei ritmi di trasmissione dei flussi che lo attraversano è maggiore della sua capacità
	___
	\   R  > C
	/__  i
	 i

	Scade un timeout di ritrasmissione.
		Il TCP pone CWND a 1*MSS.
		Si pone SSTRESH al massimo tra 2*MSS e FlightSize/2 (che è il numero di pacchetti trasmessi e mai tornati indietro. Spesso FlightSIze è pari all'ultima finestra di congestione
		
	Come risultato se CWND è minore di SSTRESH si entra in slow start.
	Il TX trasmette tutti i segmenti andati persi (Go-back-N)
	Quando CWND >= SS treshold passo a CONGESTION AVOIDANCE
	
	Congestion avoidance (incremento frazionario)
		Si incrementa la CWND di 1/CWND ad ogni ACK ricevuto.

		La finestra continua ad aumentare lentamente (linearmente con coeff.angolare piccolo)
		
	Meccanismo del TCP per quando si è a regime
		\-> Fast retransmit e fast recovery.
		Fast retransmit: quando perdi un pacchetto, contrariamente al go-back-N, fa così.
			Quando un pacchetto viene perso, il contatore ACK del ricevitore non è aggiornato. La terza volta che TX riceve lo stesso valore di ack dal ricevitore, TX interpreta questo come un NACK e procede a reinviare il pacchetto perso. Dopodiché continua ad inviare la sequenza di byte nella coda.

		Il fast recovery consiste nel portare la congestion window NON più a 1 BENSÌ a quello di prima del timeout diviso 2.
		L'andamento che vedo in rete è tipo così: /|/|/|/|/|/|/|/|/ a dente di sega 
		Noi ci fermiamo a questa prima versione del TCP, che porta il nome di una località balneare, il terzo si chiama vegas

TCP e sistemi operativi
	la versione base è Tahoe, quella di questo corso.
	Per Windows abbiamo:
		Reno / New Reno
		SACK
		ECN
		F-RTO
		CTCP
	Per Linux:
		BIC: Binary Increase Congestion control (fino alla 2.6.18)
		CUBIC = quella più usata (da 2.6.19 a 3.1)
		PRR: Proportional Rate Reduction (dalla 3.2)
	Per MacOS:
		MacTCP(fino a 7.5.1) e Open Transport(dalla 7.5.2 alla 9.2.2)
		CUBIC (dalla 10.10) e ECN (dalla 10.11 in poi)

Condivisione equa delle risorse

Flussi grandi e flussi piccoli TCP su internet
Elephant e Mice flows. In alcune versioni i flussi elefanti vengono spaventati dai flussi topolino
